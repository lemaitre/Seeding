// Include files
// from boost
#include <boost/assign/list_of.hpp>
#include <boost/array.hpp>
#include <boost/foreach.hpp>
// from Gaudi
#include "GaudiKernel/AlgFactory.h" 
#include "Event/Track.h"
#include "Event/StateParameters.h"
#include "Math/CholeskyDecomp.h"
// local
#include "PrHybridSeeding.h"
#include "PrPlaneCounter2.h"
#include "Event/MCTrackInfo.h"
#include "Event/LinksByKey.h"
#include "Event/MCHit.h"
#include "Linker/LinkedTo.h"
#include "Linker/LinkedFrom.h"
#include "Linker/AllLinks.h"
#include "Event/FTCluster.h"
#include "Event/FTLiteCluster.h"
#include "Event/MCParticle.h"
//-----------------------------------------------------------------------------
// Implementation file for class : PrHybridSeeding
//
// 2015-03-11 : renato quagliani
//-----------------------------------------------------------------------------

// Declaration of the Algorithm Factory
DECLARE_ALGORITHM_FACTORY( PrHybridSeeding )

//=============================================================================
// Standard constructor, initializes variables
//=============================================================================


PrHybridSeeding::PrHybridSeeding( const std::string& name,
                                  ISvcLocator* pSvcLocator)
: 
GaudiAlgorithm( name, pSvcLocator) ,
  m_hitManager(nullptr)
  ,m_geoTool(nullptr)
  ,m_debugTool(nullptr)
  ,m_timerTool(nullptr)
  ,m_zones(24)
{
  declareProperty("UseImprovedStereo",m_useImprovedStereo = false);
  declareProperty("UseImprovedCase0",m_useImproved = false);
  declareProperty( "UseCorrPosition" , m_useCorrPos = false);
  declareProperty( "UseCorrSlopes" , m_useCorrSlopes = false);
  declareProperty( "InputName" ,              m_inputName= LHCb::TrackLocation::Forward);
  declareProperty( "OutputName",             m_outputName=LHCb::TrackLocation::Seed);
  declareProperty( "HitManagerName",       m_hitManagerName= "PrFTHitManager");
  declareProperty( "DecodeData",              m_decodeData= false);
  declareProperty( "XOnly",                       m_xOnly= false);
  declareProperty( "MinXPlanes",                m_minXPlanes = 4);
  declareProperty( "MaxNHits",                m_maxNHits =13);
  declareProperty( "NCases" ,                    m_nCases = 3); //Max
  declareProperty( "TimingMeasurement",   m_doTiming= false);
  declareProperty( "PrintSettings",               m_printSettings= true);
  declareProperty( "UseCubicCorrection",     m_useCubic = true);
  declareProperty( "RemoveClones" ,          m_removeClones = true); // to be optimised
  declareProperty( "RemoveClonesX",         m_removeClonesX = true); // to be optimised
  declareProperty( "FlagHits",                      m_FlagHits = true);//to be impoved
  declareProperty( "RemoveFlagged",          m_removeFlagged = false);// to be improved
  declareProperty( "SizeToFlag" ,                 m_SizeFlag = 10);
  //-------------------Flag Hits Settings
  declareProperty( "Flag_MaxChi2" ,      m_MaxChi2Flag = 0.5); //Chi2 Contribution of the Hit to flag
  declareProperty( "Flag_MaxX0"  ,         m_MaxX0Flag = 600 *Gaudi::Units::mm); //Track Backward projection max value for flagging
  //--------------------X-Search Parametrisation
  //1st / Last Layer search windows
  declareProperty( "HighPAlpha",               m_alphaCorrection = 120.64 *Gaudi::Units::mm); 
  declareProperty( "TolHp",                      m_TolHp = 250.0 *Gaudi::Units::mm);
  {
    std::vector<double> tmp=boost::assign::list_of(120.64)(120.64)(120.64); 
    declareProperty( "HighP_listAlpha" , m_alphaCorrectionHighP = tmp);
  }
  {
    std::vector<double> tmp=boost::assign::list_of(280.0)(240.0)(240.0);
    
    declareProperty( "HighP_tolHp" , m_TolHighP = tmp);
  }

  
  declareProperty( "HighP_Plane4_Alpha", m_hp4_alpha = 0.00220);
  declareProperty( "HighP_Plane4_Slope", m_hp4_slope = 2.666e-3);
  declareProperty( "HighP_Plane4_TolSym",m_hp4_tol =1.2 *Gaudi::Units::mm);
  declareProperty( "HighP_Plane8_Alpha", m_hp7_alpha = 0.00215);
  declareProperty( "HighP_Plane8_TolSym", m_hp7_tol = 1.2*Gaudi::Units::mm);  
  //Add of third hit in T2
  //Case 0 
  {
    std::vector<double> Case0_ParSeed4 = boost::assign::list_of(0.7)(500.)(2000.)(6000.)(8.)(17.)(0.00220);  
    declareProperty("Case0_ParSeed4", m_Case0_ParSeed4 = Case0_ParSeed4);
  }
  
  {
    std::vector<double> Case0_ParSeed7 = boost::assign::list_of(0.7)(500.)(2000.)(6000.)(8.)(17.)(0.00215);  
    declareProperty("Case0_ParSeed7", m_Case0_ParSeed7 = Case0_ParSeed7);
  }
  
  

  //Case 1
  {
    std::vector<double> Case1_ParSeed4 = boost::assign::list_of(0.7)(500.)(2000.)(6000.)(5.5)(15.5)(0.00153);  
    declareProperty("Case1_ParSeed4", m_Case1_ParSeed4 = Case1_ParSeed4);
  }
  
  {
    std::vector<double> Case1_ParSeed7 = boost::assign::list_of(0.7)(500.)(2000.)(6000.)(5.5)(15.5)(0.00153);  
    declareProperty("Case1_ParSeed7", m_Case1_ParSeed7 = Case1_ParSeed7);
  }
  
  
  //Case 2
  {
    std::vector<double> Case2_ParSeed4 = boost::assign::list_of(1.0)(500.)(2000.)(6000.)(8.)(17.)(0.001830);  
    declareProperty("Case2_ParSeed4", m_Case2_ParSeed4 = Case2_ParSeed4);
  }
  
  {
    std::vector<double> Case2_ParSeed7 = boost::assign::list_of(1.3)(500.)(2000.)(6000.)(8.)(17.)(0.001830);  
    declareProperty("Case2_ParSeed7", m_Case2_ParSeed7 =Case2_ParSeed7);
  }
  
  //old !
  declareProperty( "x0Corr",                     m_x0Corr = 0.0023);  // Rotation angle
  declareProperty( "yOff1",                      m_yOff1 = +1.0); // for Case 0
  declareProperty( "yOff1_Loose",            m_yOff1_Loose = +1.5); // for Case 1
  declareProperty( "yOff2",                      m_yOff2 = -1.0); //L1 selection  tollerance
  declareProperty( "yOff2_Loose",            m_yOff2_Loose = -1.5); // for Case 0
  declareProperty( "maxParabolaSeedHits", m_maxParabolaSeedHits = 8); // for Case 1
  //Look up in remaining X layers
  declareProperty( "maxDelta_Par",           m_maxDeltaPar = 1.2 *Gaudi::Units::mm); //L2 selection
  declareProperty( "maxDelta_Par_Loose", m_maxDeltaPar_Loose = 1.4*Gaudi::Units::mm);
  //dRatio variation as a function of just x(zRef)
  //Look up in remaining X layers and Track Fitting  X
  declareProperty( "dRatio0",                    m_dRatio0= -0.000246); 
  declareProperty( "dRatio1",                    m_dRatio1= -4.68e-10);
  declareProperty( "dRatio2",                    m_dRatio2= -1.25e-11);
  declareProperty( "CConst" ,                    m_ConstC = 2.458e8); //Backward Projection
  //--------------------UV search  Parametrisation (inherit from PrSeedingXLayers ( to be modified)
  declareProperty("TolCoord",                    m_coord = 0.005);
  declareProperty("RemoveHole",              m_removeHole = true);
  //---Added
  declareProperty("AlphaLinearUV"   ,         m_alphaUV = 0.75);
  declareProperty("DoAsymm"       ,           m_doAsymmUV = true);
  //---
  declareProperty( "TolTyOffset",              m_tolTyOffset          = 0.0035);
  declareProperty( "TolTySlope",              m_tolTySlope          = 0.015);
  declareProperty( "TolXStereo",              m_tolXStereo         = 2700.* Gaudi::Units::mm      );
  declareProperty( "TriangleFix" ,              m_useFix               = true);
  declareProperty( "TriangleFix2nOrder",   m_useFix2ndOrder = true);
  declareProperty( "maxChi2HitsX",          m_maxChi2HitsX = 6.5);
  declareProperty( "maxChi2PerDoF",       m_maxChi2PerDoF = 8.0);
  //-------------------Clone Removal Settings
  declareProperty( "minNCommonX",       m_nCommonX=1); //for clone removal
  declareProperty( "minNCommonUV",     m_nCommonUV=4); //for clone removal in Look Up UV Hits
  // Parameters for debugging
}
//=============================================================================
// Destructor
//=============================================================================
PrHybridSeeding::~PrHybridSeeding() {} 

//=============================================================================
// Initialization
//=============================================================================
StatusCode PrHybridSeeding::initialize() {
  StatusCode sc = GaudiAlgorithm::initialize();
  if ( sc.isFailure() ) return sc;  // error printed already by GaudiAlgorithm
  if ( msgLevel(MSG::DEBUG) ) debug() << "==> Initialize" << endmsg;
  m_hitManager= tool<PrHitManager>( m_hitManagerName );
  m_geoTool = tool<PrGeometryTool>("PrGeometryTool");
  m_hitManager->buildGeometry();
  m_debugTool = 0;
  if ( "" != m_debugToolName ) {
    m_debugTool = tool<IPrDebugTool>( m_debugToolName );
    info()<<"Debug tool "<<m_debugToolName<<" loaded."<<endmsg;
  } else {
    m_wantedKey = -100;  //no debug
  }  
  if ( m_doTiming) {
    m_timerTool = tool<ISequencerTimerTool>( "SequencerTimerTool/Timer", this );
    m_timeTotal   = m_timerTool->addTimer( "PrSeeding total" );
    m_timerTool->increaseIndent();
    m_timeFromForward = m_timerTool->addTimer( "Convert Forward" );
    m_timeXProjection = m_timerTool->addTimer( "X Projection" );
    m_timeStereo      = m_timerTool->addTimer( "Add stereo" );
    m_timeFinal       = m_timerTool->addTimer( "Convert tracks" );
    m_timerTool->decreaseIndent();
  }
  if( m_decodeData )         info() << "Will decode the FT clusters!" << endmsg;
  if( m_FlagHits)                 info()<<"Will Flag the Hits" << endmsg;
  if( m_removeFlagged)      info()<<"Will Not re-use Flagged"<<endmsg;
  if( m_inputName == "")    info()<<"Standalone Seeding"<<endmsg;
  if( !(m_inputName == "")) info()<<"Forward tracks as input"<<endmsg;
  if( m_removeClones)      info()<<"Will Remove Clones"<<endmsg;
  if( m_xOnly) info()<<"Will use Only X Layers" <<endmsg;
  if( m_useFix && !m_xOnly) info()<<"WIll Use the triangle Fix"<<endmsg;
  
  if( m_printSettings){
    info() <<"======================================="<<endmsg
           << "===============GLOBAL SETTINGS============"<<endmsg
           <<" InputName                                         = "<<  m_inputName             << endmsg
           << " OutputName                                      = "<<  m_outputName           << endmsg
           << " HitManagerName                               = "<<  m_hitManagerName     << endmsg
           << " DecodeData                                        = "<<  m_decodeData          << endmsg
           << " XOnly                                                 = "<<  m_xOnly                    << endmsg
           << " MinXPlanes                                         = "<<  m_minXPlanes            << endmsg
           << " Min N HIts is 10 for 6 + 4, 9 for 5+4" <<endmsg
           << " MaxNHits                                            = "<< m_maxNHits               <<endmsg
           << " NCases                                               = "<< m_nCases                  << endmsg
      // << " UseCubicCorrection                            = "<<  m_useCubic               << endmsg
      // << " RemoveClones                                     = "<< m_removeClones         << endmsg 
      //<< " RemoveClonesX                                   = "<<m_removeClonesX << endmsg
      // <<"  FlagHits                                               = "<< m_FlagHits                 << endmsg
      // << " RemoveFlagged                                   = "<<m_removeFlagged <<endmsg
           << " TimingMeasurement                          = "<<  m_doTiming              << endmsg
           << "===========FindX Layer Settings==========="<<endmsg
           << "**************First - Last Layer  settings Standard*****************"<<endmsg
           << " 1st - Last X Layer Alpha Rotation            = "<< m_alphaCorrection <<endmsg
           << " 1st - Last X Layer Search Window           = " << m_TolHp << endmsg
           << "**************T - 2 X layers Hit addition *****************"<<endmsg
           << " Third Hit T2 search x0 Correction          = " << m_x0Corr << endmsg
           << " Third Hit T2 search Window   plus          = " << m_yOff1 << endmsg
           << " Third Hit T2 search Window   minus       = " << m_yOff2 << endmsg
           << " Third Hit T2 search Window plus Loose   = " <<m_yOff1_Loose<<endmsg
           << " Third Hit T2 search Window minus Loose = " <<m_yOff2_Loose<<endmsg
           << " Max Parabola Seed Hits                       = " << m_maxParabolaSeedHits<<endmsg
           << " ************** Remaining X layers ********************"<<endmsg
           << " LookUp Remaingin X Layers MaxDelta = " << m_maxDeltaPar<<endmsg
           << " Cubic Correction     dRatio = dRatio0 + dRatio1 * x(zRef) _ dRatio2*x(zRef)^{2}= " << m_useCubic <<endmsg
           << " dRatiio_X 0                                         = " << m_dRatio0<<endmsg
           << " dRatio_X  1 (linCorr)                            = "<< m_dRatio1<<endmsg
           << " dRatio_X  2 (quadCorr)                        = "<<m_dRatio2<<endmsg
           << " CConst BackProj                                  = "<<m_ConstC<<endmsg
           << "=================ADD UV Layer Settings=========="<<endmsg
           << "doAsymmUV                                         = "<<m_doAsymmUV  <<endmsg
           << "AlphaAsymm                                        = "<<m_alphaUV         <<endmsg
           << "TolCoord                                               = " <<m_coord             <<endmsg
           << "TolTyOffset                                            = " <<  m_tolTyOffset    << endmsg
           << "TolTySlope                                            = " <<  m_tolTySlope     << endmsg
           << "TolXStereo                                            = " <<m_tolXStereo             << endmsg
           << "Use Triangle Fix                                    = " <<m_useFix                  << endmsg
           << "Use SecondOrder `Triangle Fixing        =  " <<m_useFix2ndOrder <<endmsg
           << "*******Fit Settings"<<endmsg
           << "MaxChi2HitsX                                       = " <<m_maxChi2HitsX<<endmsg
           << "MaxChi2PerDoF                                    = " <<m_maxChi2PerDoF <<endmsg
           << "==================Clone Removal and Flag Hits Settings=========="<<endmsg
           << "Remove Clones after X searh                 = "<<m_removeClonesX<<endmsg
           << "Min Hits Common X                            = " <<m_nCommonX <<endmsg
           << "RemoveClones after add stereo UV        = "<< m_removeClones<<endmsg
           << "Min Hits Commons Total                      = " <<m_nCommonUV <<endmsg
           << "Flag the hits                                       = " << m_FlagHits <<endmsg
           << "Remove All Flagged                            = " <<m_removeFlagged<<endmsg
           << "Flag_MaxChi2 Hit                                = " << m_MaxChi2Flag<<endmsg
           << "Flag_MaxX0                                         = " <<m_MaxX0Flag <<endmsg;
    
    info()<<"Find XZ projection High momentum Alpha rotation";
    for(unsigned int kk =0;m_alphaCorrectionHighP.size()>kk;kk++){
      info()<<m_alphaCorrectionHighP[kk]<< " ";  
    }
    info()<<"Tolerance XZ first step after rotation";
    for(unsigned int kk = 0;m_TolHighP.size() >kk; kk++){
      info()<<m_TolHighP[kk]<<" ";
    }
    
    info()<<"=======Special Plane4 settings for high P search===="<<endmsg
          <<" Plane 4 alphaX0                               = "<<m_hp4_alpha<<endmsg
          <<" Plane 4 Slope                                  = "<<m_hp4_slope<<endmsg
          <<" Plane 4 TolSym                               = "<<m_hp4_tol<<endmsg 
          <<" Plane 8 alphaX0                              = "<<m_hp7_alpha<<endmsg
          <<" Plane 8 TolSym                               = "<<m_hp7_tol<<endmsg;
  }
  return StatusCode::SUCCESS;
}


//=============================================================================
// Main execution
//=============================================================================
StatusCode PrHybridSeeding::execute() {
  if ( msgLevel(MSG::DEBUG) ) debug() << "==> Execute" << endmsg;
  if ( m_doTiming ) 
  {
    m_timerTool->start( m_timeTotal );
    m_timerTool->start( m_timeFromForward );
  }
  LHCb::Tracks* result = new LHCb::Tracks();
  put( result, m_outputName );
  if( m_decodeData ){
    debug()<<"Decoding Data"<<endmsg;
    m_hitManager->decodeData();
    debug()<<"Decoding Done"<<endmsg;
  }
  int multiplicity[24];
  int multiplicityTot = 0;
  char zoneName[100];
  // UNFLAG USED TO ALL HITS
  debug()<<"UNFLAGGING ALL HITS"<<endmsg;
  for ( unsigned int zone = 0; m_hitManager->nbZones() > zone; ++zone ) {
    multiplicity[zone]=0;
    sprintf (zoneName, "Multiplicity_InZone_%i",zone);
    for ( PrHits::const_iterator itH = m_hitManager->hits( zone ).begin();
          m_hitManager->hits( zone ).end() != itH; ++itH ) {
      (*itH)->setUsed( false );
      multiplicity[zone]++;
      multiplicityTot++;
    }
  }
  
  //========================================================
  // Remove Seed segment if we pass the  Forward as Input
  //========================================================
  
  if ( "" != m_inputName){
    debug()<<"Removing Seed Segment from Forward Tracking"<<endmsg;
    for(int i = 0; i < 24; i++){
      PrHitZone* zone = m_hitManager->zone(i);
      std::stable_sort( zone->hits().begin(),  zone->hits().end(), compLHCbID());
    }
    LHCb::Tracks* forward = get<LHCb::Tracks>( m_inputName );
    //Loop over forward tracks container
    for ( LHCb::Tracks::iterator itT = forward->begin(); forward->end() != itT; ++itT ) {
      //Vector of LHCbID
      std::vector<LHCb::LHCbID> ids;
      ids.reserve(20);
      // Loop over LHCbIDs of the forward track
      for ( std::vector<LHCb::LHCbID>::const_iterator itId = (*itT)->lhcbIDs().begin();
            (*itT)->lhcbIDs().end() != itId; ++itId ) {
        if ( (*itId).isFT() && (*itId).ftID().layer() < 12 ) {
          LHCb::FTChannelID ftId =(*itId).ftID();
          int zoneNb = 2 * ftId.layer() + ftId.mat(); //zones top are even (0, 2, 4, ....,22)  and zones bottom are odd
          //Load the PrHitZone
          PrHitZone* zone = m_hitManager->zone(zoneNb);
          
          // -- The hits are sorted according to LHCbID, we can therefore use a lower bound to speed up the search
          
          PrHits::iterator itH = std::lower_bound(  zone->hits().begin(),  zone->hits().begin(), *itId, lowerBoundLHCbID() );
          
          for ( ; zone->hits().end() != itH; ++itH ) {
            if( *itId < (*itH)->id() ) break;
            if ( (*itH)->id() == *itId ) (*itH)->setUsed( true );
          }
          ids.push_back( *itId );
        }
      }
      
      // Forward output loaded to TTrack container with History flag
      LHCb::Track* seed = new LHCb::Track;
      seed->setLhcbIDs( ids );
      seed->setType( LHCb::Track::Ttrack );
      seed->setHistory( LHCb::Track::PrSeeding );
      seed->setPatRecStatus( LHCb::Track::PatRecIDs );
      seed->addToStates( (*itT)->closestState( 9000. ) );
      result->insert( seed );
    }
    
   
    
    //=======================================
    // Sort hits according to x for each zone
    //=======================================
    for(int i = 0; i < 24; i++){
      PrHitZone* zone = m_hitManager->zone(i);
      std::stable_sort( zone->hits().begin(),  zone->hits().end(), compX());
    }
  }
  //=======================================
  // Fill zones
  //=======================================
  m_zones.clear();
  for(int i = 0; i < 24; i++){
    m_zones[i] = m_hitManager->zone(i);
  }
  //==========================================================
  //END FLAGGING HITS FROM FORWARD
  //==========================================================
  // Hits are ready to be processed
  //==========================================================
  m_trackCandidates.clear();
  if ( m_doTiming ) {
    m_timerTool->stop( m_timeFromForward );
  }
  //========================================================
  //------------------MAIN SEQUENCE IS HERE-----------------
  //========================================================
  
  // ----- Loop through lower and upper half
  for ( unsigned int part= 0; 2 > part; ++part ){    
    //----- Loop For difference Cases 
    for (unsigned int icase = 0; m_nCases>icase;++icase)
    {  
      
      //findXProjectionsHighMomentum( part,icase);
      if(icase ==0 && m_useImproved){
        findXProjectionsHighMomentum2(part);
      }
      if(icase!=0) findXProjectionsHighMomentum(part, icase);
      if(m_removeClonesX && !m_xOnly) removeClonesX(m_nCommonX); //if xOnly true already clones removed in findXProjectionHighMomentum
      if(!m_xOnly) addStereo( part, icase ); //to be written (method to addStereoLayers)
      //Remove Clones at the end of each single case?
      if(m_removeClones && !m_xOnly) removeClones(m_nCommonUV);
      //Flag found Hits at the end of each single case?
      if (m_FlagHits && (icase ==0 || icase ==1))
        flagHits(icase);
    }//end Case Loop 
    
    //if not done before do it here?
    //if( m_removeClones)
    //{
    //removeClones();
    //}
  }
  // Convert to LHCb Tracks
  debug()<<"Making LHCb Tracks"<<endmsg;
  makeLHCbTracks( result );
  debug()<<"Making LHCb Tracks Done"<<endmsg;
  return StatusCode::SUCCESS;
}

//=============================================================================
//  Finalize
//=============================================================================
StatusCode PrHybridSeeding::finalize() {
  
  if ( msgLevel(MSG::DEBUG) ) debug() << "==> Finalize" << endmsg;
  return GaudiAlgorithm::finalize();
}
//==================
//Add Stereo void
//==================
void PrHybridSeeding::addStereo(unsigned int part, unsigned int iCase)
{
  double zT1_1 = 0.;
  double zT1_2 = 0.;
  double zT2_1 = 0.;
  double zT2_2 = 0.;
  double zT3_1 = 0.;
  double zT3_2 = 0.;
  
  for(unsigned int kk = 2 ; 22>kk ;kk++)
  {
    if(m_hitManager->zone(kk)->isX()) continue; 
    if(m_hitManager->zone(kk)->planeCode()==1){                                    
      zT1_1 = m_hitManager->zone(kk)->z();                              
    }
    if(m_hitManager->zone(kk)->planeCode()==2){
      zT1_2 = m_hitManager->zone(kk)->z();                                  
    }                                                                           
    if(m_hitManager->zone(kk)->planeCode()==5){
      zT2_1 = m_hitManager->zone(kk)->z();                                  
    }                                                                          
    if(m_hitManager->zone(kk)->planeCode()==6){
      zT2_2 = m_hitManager->zone(kk)->z();
    }                                                                           
    if(m_hitManager->zone(kk)->planeCode()==9){   
      zT3_1 = m_hitManager->zone(kk)->z();                                  
    }
    if(m_hitManager->zone(kk)->planeCode()==10){
      zT3_2 = m_hitManager->zone(kk)->z();                                  
    }
  }
  double zT1Mid = (zT1_1+zT1_2)/2.;
  double zT2Mid = (zT2_1+zT2_2)/2.;
  double zT3Mid = (zT3_1+zT3_2)/2.;
  
  PrSeedTrack2s xProjections;
  for( PrSeedTrack2s::iterator itT1 = m_xCandidates.begin();m_xCandidates.end() != itT1; ++itT1){
    if( !(*itT1).valid()) continue;
    xProjections.push_back( *itT1);  
  }
  unsigned int firstZone = part+2; //1st station U Layers
  unsigned int lastZone = part+22;
  if(m_useFix){
    firstZone = 2;
    lastZone = 22;
  }
  for( PrSeedTrack2s::iterator itT = xProjections.begin();xProjections.end() != itT; ++itT){
    PrHits myStereo;  
    myStereo.reserve(30);
    const unsigned int stepSize = m_useFix ? 1:2;
    for(unsigned int kk = firstZone; lastZone >kk;kk+=stepSize){
      if(m_hitManager->zone(kk)->isX()) continue;
      double dxDy = m_hitManager->zone(kk)->dxDy();
      double lambda = std::fabs(dxDy);
      //dxDy()<<"part = "<<part<<"\n dxDy = "<<dxDy<<"\n PlaneCode ="<<m_hitManager->zone(kk)->planeCode()<<endmsg;
      double zPlane = m_hitManager->zone(kk)->z();
      double xPred = (*itT).x(zPlane);
      float xMin = xPred + m_tolXStereo* dxDy;
      float xMax = xPred - m_tolXStereo* dxDy;
      if(m_doAsymmUV){
        if(part==0){
          if(dxDy>0) //U-Layers
          {
            xMin =xPred-lambda*(m_tolXStereo);//180
            xMax =xPred+m_alphaUV;
            if(kk%2==1 && m_useFix) //you are looking on opposite side for U layers when you look for y>0
            {
              xMin = xPred-25.0*lambda;//25 is the max value of yMin
              xMax = xPred+m_alphaUV;
            }
          }
          if(dxDy<0)//V-Layers
          {
            xMin = xPred - m_alphaUV;
            xMax = (xPred)+lambda*(m_tolXStereo);
            if(kk%2 ==1 && m_useFix){
              xMin = xPred - m_alphaUV;
              xMax = xPred + 25.0*lambda;
            }
          }
        }
        if(part==1)//lower
        {
          if(dxDy>0)
          {
            xMin = xPred - m_alphaUV;
            xMax = xPred + (m_tolXStereo)*lambda;
            if(kk%2==0 && m_useFix)
            {
              xMin=xPred - m_alphaUV;
              xMax=xPred + 25.0*lambda;
            }
          }
          if(dxDy<0){
            xMin =  xPred - (m_tolXStereo)*lambda;
            xMax =  xPred + m_alphaUV;
            if(kk%2==0 && m_useFix)
            {
              xMin= xPred - 25.0*lambda;
              xMax= xPred + m_alphaUV;
            }
          }
        }
      }
      
      
      if ( xMin > xMax ) {
        always()<<"Wrong xMin xMax at UV"<<endmsg;
        float tmp = xMax;
        xMax = xMin;
        xMin = tmp;
      }
      PrHits::iterator itH = m_hitManager->zone(kk)->hits().begin();
      for ( ;    m_hitManager->zone(kk)->hits().end() != itH; ++itH ) { 
        if ( (*itH)->x() < xMin ) continue;
        if ( (*itH)->x() > xMax ) continue;
        if (m_useFix2ndOrder){
          if(part==0 && kk%2==1)
          {//this is a more sophisticated triangle fixing removal
            if(dxDy>0)
            {
              if( ( (*itH)->x()-xPred) >.1 ) continue;
              if( ( (*itH)->x()-xPred) < -.4 - 1.5/18.*(*itH)->yMax()) continue;
            }
            if(dxDy<0)
            {
              if( ( (*itH)->x()-xPred) < -.1) continue;
              if( ( (*itH)->x()-xPred) > +.4 + 1.5/18.*(*itH)->yMax()) continue;
            } 
          }
          if((part==1) && kk%2==0)
          {//this is a even more sophisticated triangle Fixing(should remove a bit of pollution
            if(dxDy>0)
            {
              if( ( (*itH)->x()-xPred) < -.1 ) continue;
              if( ( (*itH)->x()-xPred) > + .4 - 1.5/18.*(*itH)->yMin()) continue;
            }
            if(dxDy<0)
            {
              if( ( (*itH)->x()-xPred) > .1) continue;
              if( ( (*itH)->x()-xPred) < -.4 + 1.5/18.*(*itH)->yMin()) continue;
            } 
          }
        }
        (*itH)->setCoord( ((*itH)->x() - xPred) / dxDy  / zPlane );
        if ( 1 == part && (*itH)->coord() > m_coord ) {
          continue;
        }
        if ( 0 == part && (*itH)->coord() <  -m_coord ) {
          continue;
        }
        if (m_removeFlagged && (*itH)->isUsed()) continue;
        if (m_removeHole){ 
          // For tracks where we expect to find hit in X where you have the hole 
          //it doesn't make sense to collect hits ay a Y where you have the hole!
          double deltaat0 = (*itH)->x()-xPred;
          //Radius of the Hole in x : 83.2 mm ; in y : 7.7/sin(5 deg) ~ 88.3
          if( std::pow(deltaat0/7.7,2)+std::pow(xPred/83.0,2) < 1 ) continue;
        }
        myStereo.push_back( *itH );
      }
    }
    //compute the z Position in the middle of the 2 U-V layers
    // double zMidT1 = (m_zones[s_T1]+zT1_2)/2.; 
    //                  double zMidT2 = (zT2_1+zT2_2)/2.;
    //                  double zMidT3 = (zT3_1+zT3_2)/2.;
    //                  double xPred_zMidT1 = (*itT).x(zMidT1);
    //                  double xPred_zMidT2 = (*itT).x(zMidT2);
    //                  double xPred_zMidT3 = (*itT).x(zMidT3);
    
    // (*itT).setxPredT1Mid(xPred_zMidT1);
    // (*itT).setxPredT2Mid(xPred_zMidT2);
    // (*itT).setxPredT3Mid(xPred_zMidT3);
    //Check here pairing of hits ?
    std::stable_sort( myStereo.begin(), myStereo.end(), PrHit::LowerByCoord() );
    PrPlaneCounter2 plCount;
    //Save position of this x candidate, for later use
    //My Stereo is a collection of Hits in the stereo Layers 
    unsigned int minUV = 4; //minimal different UV layer Hits
    unsigned int minTot = 10; //minimal different number of Hits
    if(iCase == 0){
      if((*itT).hits().size()== 6 ) { minUV = 4; minTot = 10;}
      if((*itT).hits().size()== 5 ) { minUV = 5; minTot = 10;}
      if((*itT).hits().size()== 4 ) { minUV = 6; minTot = 10;}
    }
    if(iCase == 1)
    {
      if((*itT).hits().size()== 6 ) { minUV = 4; minTot = 10;}
      if((*itT).hits().size()== 5 ) { minUV = 4; minTot = 9;}
      if((*itT).hits().size()== 4 ) { minUV = 5; minTot = 9;}
    }
    if(iCase ==2){
      if((*itT).hits().size()==6 ) minUV = 4; minTot = 9;
      if((*itT).hits().size()==5 ) minUV = 4; minTot = 9;
      if((*itT).hits().size()==4 ) minUV = 5; minTot = 9; 
    }
    
    unsigned int firstSpace = m_trackCandidates.size();
    PrHits::iterator itBeg = myStereo.begin();//first hit in U-V layer with small Ty
    PrHits::iterator itEnd = itBeg + minUV;//go ahead of 5 UVHits
    //Long tracks >5 GeV tolTyOffset = 0.002
    //Long tracks > 5 GeV:
    // 
    double signSlope = (std::fabs((*itT).X0()) >200.)? +1. :  -1. ;  //true
    double TyOffset = m_tolTyOffset;
    double TySlope = m_tolTySlope;
    double minTy = 0.;
    while ( itEnd < myStereo.end() ) {
      if( m_useImprovedStereo && m_useImproved){
        if( (*itBeg)->coord() < 0.12){
          TyOffset = m_tolTyOffset;
          TySlope = 0.;
        }
        if( std::fabs((*itBeg)->coord()) >=0.12){
          TyOffset = m_tolTyOffset + signSlope*( m_tolTyOffset/(0.24-0.12)*(-0.12));
          TySlope = signSlope*m_tolTyOffset/(0.24-0.12); 
        }
      }
      double tolTy = m_tolTyOffset + m_tolTySlope * fabs( (*itBeg)->coord());
      if(m_useImprovedStereo )
        tolTy = TyOffset + TySlope * fabs( (*itBeg)->coord());
      
      if(iCase==0 && m_useImproved && !m_useImprovedStereo){ //long >5 GeV cut
        tolTy = m_tolTyOffset;
      }
      // Take the next 4 hits and check if inside a given tolerance?
      if ( (*(itEnd-1))->coord() - (*itBeg)->coord() < tolTy ) {
        while( itEnd+1 < myStereo.end() &&
               (*itEnd)->coord() - (*itBeg)->coord() < tolTy ) {
          ++itEnd; //extend last hit until you don't reach end
          
        }
        plCount.set( itBeg, itEnd); 
        // bool T1Pair=false;
        // bool T2Pair=false;
        // bool T3Pair=false;
        if( (minUV-1) < plCount.nbDifferent() && plCount.isOKUV()){ //this ensure to have in the hough cluster a min Number of diffe// rent UV layers and also the reconstructibility condition!
          // if(m_useImprovedStereo)
          // {
          //   bool findPairT1;
          //   if(plCount.nbDifferentUVT1() ==2)
          //   {
          //     findPairT1 = true;
          //   }
          //   if(plCount.nbDifferentUVT2() == 2)
          //   {
          //     findPairT2 = true;
          //   }
          //   if(plCount.nbDifferentUVT2() == 2)
          //   {
          //     findPairT3 = true;
          //   }
            
            
              
          // bool T1Pair=false;
          // bool T2Pair=false;
          // bool T3Pair=false;
          // if(plCount.nbDifferentUVT1()==2){
          //   T1Pair = true;
          // }
          // if(!T1Pair && plCount.nbDifferentUVT2()==2){
          ////    T2Pair = true
          // // }
          // // if(!T1Pair && !T2Pair && plCount.nbDifferentUVT3()==2){
          // //   T3Pair = true;
          // // }
          // // //Fill the 
          //   std::vector<PrHit*> T1U;
          //   std::vector<PrHit*> T1V;
          //   std::vector<PrHit*> T2U;
          //   std::vector<PrHit*> T2V;
          //   std::vector<PrHit*> T3U;
          //   std::vector<PrHit*> T3V;
          //   for (PrHits::iterator itH = itBeg; itEnd!=itH; ++itH){
          //     if( (*itH)->planeCode() ==1) T1U.push_back( (*itH));
          //     if( (*itH)->planeCode() ==2) T1V.push_back( (*itH));
          //     if( (*itH)->planeCode() ==5) T2U.push_back( (*itH));
          //     if( (*itH)->planeCode() ==6) T2V.push_back( (*itH));
          //     if( (*itH)->planeCode() ==9) T3U.push_back( (*itH));
          //     if( (*itH)->planeCode() ==10) T3V.push_back( (*itH));
          //   }
          //   for(subCase == 0; subCase<3;subCase++){
          //     if(subCase==0 && T1Pair){
          //       std::vector<PrHit*> first  = T1U;
          //       std::vector<PrHit*> second = T1V;
          //       std::vector<PrHit*> third  = T2U;
          //       std::vector<PrHit*> fourth = T2V;
          //       std::vector<PrHit*> fifth  = T3U;
          //       std::vector<PrHit*> sixth  = T3V;
          //       double zMidFirst = zMidT1;
          //       double zMidSecond = zMidT2;
          //       double zMidThird = zMidT3;
          //       double xMidFirst = (*itT)->x(zMidT1);
          //       double xMidSecond = (*itT)->x(zMidT2);
          //       double xMidThird = (*itT)->x(zMidT3);
          //       //generate Pairs in T1 to project in T2 and T3
          //       PrHit* fHitU = nullptr;
          //       for(PrHits::iterator itH1 = T1U.hits().begin(); T1U.hits().end(); ++itH){
          //         fHit = (*itH) ;
          //         PrHit* fHitV = nullptr;
          //         for(PrHits::iterator itH2 = T1V.hits().begin();T1V.hits().end(); ++itH){
          //           fHitV = (*itH1);
          //           double ty2Hit = ( fHitV->coord()*fHitU->z() - fHitU->coord()*fHitV->z()) /(fHitV->z() - fHitU->z()) ;
          //   //         //cut on ty2Hit? if(abs(ty2Hit)< ?)
          //           if( ( (fHitU->x() + fHitV->x())/2. - ( ty2Hit/2. )*( fHitV->z() - fHitU->z())*lambda ) ){//remove the y correction?
          //             continue;
          //           }
            
        
        //         for(PrHits::iterator itH3 = T1U.hits().begin(); T1U.hits().begin();
        //         //here pairs
        //       }
        //     }
        //   }
        
          
        
        
        
        PrSeedTrack2 temp( *itT );
        //before add the hit on the track we do a small fit for y ?
        //std::vector<PrHit*>UVHits;
        // for (PrHits::iterator itH = itBeg; itEnd!=itH; ++itH){
        //   UVHits.push_back(itH);
        // }
        // double ay;
        // doubleby by;
        //Ok = fitYLine(UVHits, plCount, ay,by); //this will remove hits and pass the best alligned combination
        
        for ( PrHits::iterator itH = itBeg; itEnd != itH; ++itH ) {
          temp.addHit( *itH );
        }
        //for all hit added minCoord and so on and cut on that
        bool ok = fitSimultaneouslyXY( temp , 0, iCase);
        int step = 1;
        if(temp.hits().size()>m_maxNHits) ok = false; //Max N hits is 13 here
        while ( !ok && temp.hits().size() > minTot) {
          if(!m_useImprovedStereo){
              ok = removeWorstAndRefit( temp , step  , iCase);
          }
          if( m_useImprovedStereo){
            ok = removeWorstAndRefit( temp, step, 10);
          }
          step++;
          if(temp.hits().size()>m_maxNHits) ok = false;
        }
        if ( ok ) {
          setChi2( temp );
          float maxChi2 = m_maxChi2PerDoF + 6*temp.xSlope(9000)*temp.xSlope(9000);
          if(m_useImproved && iCase==0) maxChi2 = 16.;
          double minSize = minTot;
          //number of hits hard coded??? More than in PatSeeding? 
          if ( temp.hits().size() >= minSize ||
               temp.chi2PerDoF() < maxChi2 ) {
            m_trackCandidates.push_back( temp );
            }
          itBeg += minUV-1;//standard
        }
        }
        
      }
      
      ++itBeg;
      itEnd = itBeg + minUV;
    }
    //Keep the cleanest one
    // if(m_trackCandidates.size()>firstSpace+1){
    //   for( unsigned int kk = firstSpace; m_trackCandidates.size()-1>kk;++kk){
    //     if(!m_trackCandidates[kk].valid()) continue;
    //     for( unsigned int ll = kk +1 ; m_trackCandidates.size()>ll ;++ll){
    //       if( !m_trackCandidates[ll].valid()) continue;
    //       PrPlaneCounter2 llTrack;
    //       llTrack.set( m_trackCandidates[ll].hits().begin(), m_trackCandidates[ll].hits().end());
    //       PrPlaneCounter2 kkTrack;
    //       kkTrack.set( m_trackCandidates[kk].hits().begin(), m_trackCandidates[kk].hits().end());
    //       if( llTrack.nbDifferent() < kkTrack.nbDifferent()){
    //         m_trackCandidates[ll].setValid(false);
    //       }else if( llTrack.nbDifferent() > kkTrack.nbDifferent())
    //       {
    //         m_trackCandidates[kk].setValid(false);
    //       }else if( m_trackCandidates[kk].chi2() < m_trackCandidates[ll].chi2())
    //       {
    //         m_trackCandidates[ll].setValid(false);
    //       }else{
    //         m_trackCandidates[kk].setValid(false);
    //  }
    //
    //}
    //}
    //}
    //    === Remove bad candidates: Keep the best one for this input track
    if ( m_trackCandidates.size() > firstSpace+1 ) {
      for ( unsigned int kk = firstSpace; m_trackCandidates.size()-1 > kk ; ++kk ) {
        //maybe just compare nbDifferent? yes maybe it's the best way
        if ( !m_trackCandidates[kk].valid() ) continue;
        for ( unsigned int ll = kk + 1; m_trackCandidates.size() > ll; ++ll ) {
          if ( !m_trackCandidates[ll].valid() ) continue;
          if ( m_trackCandidates[ll].hits().size() < m_trackCandidates[kk].hits().size() ){
            m_trackCandidates[ll].setValid( false );
          } else if ( m_trackCandidates[ll].hits().size() > m_trackCandidates[kk].hits().size() ) {
            m_trackCandidates[kk].setValid( false );
            //         //equal size, take the one with the better chi2?
          } else if ( m_trackCandidates[kk].chi2() < m_trackCandidates[ll].chi2() ) {
            m_trackCandidates[ll].setValid( false );
          } else {
            m_trackCandidates[kk].setValid( false );
          }
        }
      }//end loop track Candidates for removal bad tracks
    }//loop candidates removal 
  }//end loop xProjections
  m_xCandidates.clear(); //At the end of each case delete it or you
}



  

void PrHybridSeeding::findXProjectionsHighMomentum(unsigned int part, unsigned int iCase)
{
  m_xCandidates.clear();
  PrHits parabolaSeedHits;
  std::vector<PrHits> xHitsLists; //vector of list of Hits
  PrHits xHits;
  
  //just do the 1st one here //1st layer and last one
  int firstZoneId;
  int lastZoneId;
  if(0 == iCase){
    firstZoneId = s_T1X1 | part;
    lastZoneId  = s_T3X2 | part;
  }else if ( 1 == iCase ){
    firstZoneId = s_T1X2 | part;
    lastZoneId  = s_T3X2 | part;
  }else if ( 2 == iCase ){
    firstZoneId = s_T1X2 | part;
    lastZoneId  = s_T3X1 | part;
  }else if ( 3 == iCase ){
    firstZoneId = s_T1X1 | part;
    lastZoneId  = s_T3X1 | part;
  }
  if (msgLevel(MSG::DEBUG)) debug()<<"\t Loading Case Hit in first and last Zone"<<endmsg;
  PrHitZone* fZone = m_zones[firstZoneId];
  PrHitZone* lZone = m_zones[lastZoneId];
  if (msgLevel(MSG::DEBUG)) debug()<<"Hits in last and first Zone Loaded"<<endmsg;
  //load hits in first zone and last one
  PrHits& fHits = fZone->hits();
  PrHits& lHits = lZone->hits();
  double zFirst     = fZone->z(0.); //First  Zone Z value
  double zLast      = lZone->z(0.); //First  Zone Z value
  double DeltaZ = zLast-zFirst;     //Delta First-Last
  // std::vector<PrHitZone*> xZones;
  
  //std::vector<PrHitZone*> xZones({
  //  m_zones[s_T1X1 | part],
  //  m_zones[s_T1X2 | part],
  //  m_zones[s_T2X1 | part],
  //  m_zones[s_T2X2 | part],
  //  m_zones[s_T3X1 | part],
  //  m_zones[s_T3X2 | part]
  //});
  std::vector<PrHitZone*> xZones;
  xZones.reserve(4);
  for (int xZoneId : {s_T1X1, s_T1X2, s_T2X1, s_T2X2, s_T3X1, s_T3X2}){
    xZoneId |= part;
    if (xZoneId != firstZoneId && xZoneId != lastZoneId) {
      xZones.push_back(m_zones[xZoneId]);
    }
  }
  //PrHits::iterator itLBeg = lHits.begin();
  if (msgLevel(MSG::DEBUG)) debug()<<"Hits in the InBetween Zones Loaded"<<endmsg;
  if (msgLevel(MSG::DEBUG)) debug()<<"Will Loop over Hits in first Zone"<<endmsg;
  
  std::vector<double> Parameters_Seed4;
  std::vector<double> Parameters_Seed7;
  if(iCase ==0){
    Parameters_Seed4 = m_Case0_ParSeed4;
    Parameters_Seed7 = m_Case0_ParSeed7;
  }
  if(iCase ==1){
    Parameters_Seed4 = m_Case1_ParSeed4;
    Parameters_Seed7 = m_Case1_ParSeed7;
  }
  if(iCase ==2){
    Parameters_Seed4 = m_Case2_ParSeed4;
    Parameters_Seed7 = m_Case2_ParSeed7;
  }
  for (PrHit* fHit : fHits) {
    if ( 0 != iCase && fHit->isUsed() && m_removeFlagged ) continue;
    //define search window as a function of the x in the first layer
    double tx_inf =  fHit->x()/zFirst; 
    double xProjeInf = tx_inf*zLast;
    double tolHp = m_TolHp;
    double alpha = m_alphaCorrection;
    
    if(iCase ==1){
      alpha = 280.;
      tolHp = 400.; //increase search window for case 1 
    }
    if(iCase ==2){
      tolHp = 800.;// increase even more the search window for case 2
      alpha = 1200.;
    }
    
    double maxXl = xProjeInf + tx_inf*alpha  +tolHp;
    double minXl = xProjeInf + tx_inf*alpha  -tolHp;;
    if(maxXl < minXl){
      double temp = maxXl;
      minXl = maxXl;
      maxXl = temp;
    }
#ifdef TRUTH_MATCH_Histos
    char[100] min;
    char[100] max;
    sprintf(min,"L0Selection/HighMomentum/Case%i/minXl_vs_tinf",iCase);
    sprintf(max,"L0Selection/HighMomentum/Case%i/maxXl_vs_tinf",iCase);
    plot2D(minXl,tx_inf,min,"minXl vs t_{x}^{inf};minXl[mm];t_{x}^{inf}",-3000.,3000.,-0.5,0.5,200,200);
    plot2D(maxXl,tx_inf,max,"maxXl vs t_{x}^{inf};maxXl[mm];t_{x}^{inf}",-3000.,3000.,-0.5,0.5,200,200);
#endif TRUTH_MATCH_Histos

    
    if (msgLevel(MSG::DEBUG)) debug()<<"iCase "<<iCase<<"\t X last \t "<<minXl<<"\n\t\t\t Max X last \t "<<maxXl<<endmsg;
    if (msgLevel(MSG::DEBUG)) debug()<<"Will Loop over Last Layer"<<endmsg;
    PrHits::iterator itL = std::lower_bound(lHits.begin(), lHits.end(), minXl, lowerBoundX());
    PrHits::iterator itLEnd = std::upper_bound(lHits.begin(), lHits.end(), maxXl, upperBoundX());
    PrHit* lHit;
    for (; itLEnd != itL; ++itL) {
      lHit = *itL;
      if(nullptr == lHit){ 
        if (msgLevel(MSG::DEBUG)) debug()<<"Not Picking Hits in Last layer in the good search Window"<<endmsg;
        break;
      }
      if(lHit->x() > maxXl) break;
      if ( 0 != iCase && lHit->isUsed() && m_removeFlagged) continue;
      
      double tx_pickedcombination = (lHit->x()-fHit->x())/DeltaZ;
      parabolaSeedHits.clear();
      parabolaSeedHits.reserve(8);
      double x0 = fHit->x()-tx_pickedcombination*zFirst;
      //*new
      double CorrX0 =  Parameters_Seed4[6]*x0;
      double hp4alpha = Parameters_Seed4[6];
      double hp7alpha = Parameters_Seed7[6];
      double x0new = x0*(1.+ Parameters_Seed4[6]);
#ifdef TRUTH_MATCH
      //2 Hit associator (alredy selected indeed)
      bool assoc2Hit = false;
      LinkedTo<LHCb::MCParticle> ftLink(evtSvc(),msgSvc(),LHCb::FTClusterLocation::Default);
      LHCb::FTChannelID idFirst = id.ftID();
      LHCb::MCParticle* part = fLink.first(idFirst);
      while(0!=part){
        assoc2Hit = matchKey( part->key());
        if(assoc2Hit) break;
        part = fLink.next();
      }
      char[100] truthSelected;
      char[100] titleSelected;
      sprintf(titleSelected,"#Delta (X_{Hit}^{Last} - x_{inf}^{proj};#Delta (X_{Hit}^{Last} - x_{inf}^{proj}) [mm];Counts");
      char[100] truthSelectedCorrected;
      char[100] titleSelectedCorrected;
      sprintf(titleSelectedCorrected,"#Delta (X_{Hit}^{Last} - x_{inf^{proj} Corr;#Delta (X_{Hit}^{Last} - x_{inf}^{proj}) [mm] Corr;Counts");
      
      char[100] SelectedVsTxInf;
      char[100] titleSelectedVsTxInf;
      sprintf(titleSelectedVsTxInf,"t_{x} infinte projection vs #Delta(x_{Last} - x_{inf}^{proje} True;t_{x}^{inf};#Delta(x_{last}-x_{inf}) [mm] ");
      char[100] SelectedVsTxInfCorrected;
      char[100] titleSelectedVsTxInfCorrected;
      sprintf(titleSelectedVsTxInfCorrected,"t_{x} infinte projection vs #Delta(x_{Last} - x_{inf}^{proje} True;t_{x}^{inf};#Delta(x_{last}-x_{inf}) [mm]");
      


      char[100] x0Vstx;
      char[100] titlex0Vstx;
      sprintf(titlex0Vstx,"x_{0} Vs t_{x}^{inf} ;x_{0};t_{x}^{inf}");
      if(assoc2Hit)
      {
        sprintf(truthSelected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/AllAssociated",iCase); 
        sprintf(truthSelectedCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/AllAssociated_withCorr",iCase);
        sprintf(SelectedVsTxInf,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/AllAssociated",iCase);
        sprintf(SelectedVsTxInfCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/AllAssociated_withCorr",iCase);
        
        sprintf(x0Vstx,"L0Selection/HighMomentum/Case%i/X0VsTx/AllAssociated",iCase);
        plot2D(x0,tx_inf,x0Vstx,titlex0Vstx , -8000. , 8000., -0.6,0.6,300,200);
        
        
        plot(lHit->x()-xProjeInf,truthSelected,    titleSelected,-2000.,2000.,200);
        plot(lHit->x()-xProjeCorrected,truthSelectedCorrected,    titleSelectedCorrected,-2000.,2000.200);
        plot2D(tx_inf,lHit->x()-xProjeInf,SelectedVsTxInf,   titleSelectedVsTxInf,-0.6,0.6,-2000.,2000.,200,300);
        plot2D(tx_inf,lHit->x()-xProjeCorrected,  titleSelectedVsTxInfCorrected,-0.6,0.6,-400.,400.,200,300);
        
        
        if( !isWanted(part)){
          sprintf(truthSelected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/NotWanted",iCase);
          sprintf(truthSelectedCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/NotWanted_withCorr",iCase);
          sprintf(SelectedVsTxInf,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/NotWanted",iCase);
          sprintf(SelectedVsTxInfCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/NotWanted_withCorr",iCase);
          plot(lHit->x()-xProjeInf,truthSelected,    titleSelected,-2000.,2000.,200);
          plot(lHit->x()-xProjeCorrected,truthSelectedCorrected,    titleSelectedCorrected,-2000.,2000.200);
          plot2D(tx_inf,lHit->x()-xProjeInf,SelectedVsTxInf,   titleSelectedVsTxInf,-0.6,0.6,-2000.,2000.,200,300);
          plot2D(tx_inf,lHit->x()-xProjeCorrected,  titleSelectedVsTxInfCorrected,-0.6,0.6,-400.,400.,200,300);

          sprintf(x0Vstx,"L0Selection/HighMomentum/Case%i/X0VsTx/NotWanted_withCorr",iCase);
          plot2D(x0,tx_inf,x0Vstx,titlex0Vstx , -8000. , 8000., -0.6,0.6,300,200);
        }
        if( isWanted(part)){
          if(part->p()>5000.){
            sprintf(truthSelected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/Wanted_more5GeV",iCase);
            sprintf(truthSelectedCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/Wanted_more5GeV_withCorr",iCase);
            sprintf(SelectedVsTxInf,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/Wanted_more5GeV",iCase);
            sprintf(SelectedVsTxInfCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/Wanted_more5GeV_withCorr",iCase);
            plot(lHit->x()-xProjeInf,truthSelected,    titleSelected,-2000.,2000.,200);
            plot(lHit->x()-xProjeCorrected,truthSelectedCorrected,    titleSelectedCorrected,-2000.,2000.200);
            plot2D(tx_inf,lHit->x()-xProjeInf,SelectedVsTxInf,   titleSelectedVsTxInf,-0.6,0.6,-2000.,2000.,200,300);
            plot2D(tx_inf,lHit->x()-xProjeCorrected,  titleSelectedVsTxInfCorrected,-0.6,0.6,-400.,400.,200,300);
            
            sprintf(x0Vstx,"L0Selection/HighMomentum/Case%i/X0VsTx/Wanted_more5GeV",iCase);
            plot2D(x0,tx_inf,x0Vstx,titlex0Vstx , -8000. , 8000., -0.6,0.6,300,200);
          }
          if(part->p()>3000.){
            sprintf(truthSelected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/Wanted_more3GeV",iCase);
            sprintf(truthSelectedCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/Wanted_more3GeV_withCorr",iCase);
            sprintf(SelectedVsTxInf,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/Wanted_more3GeV",iCase);
            sprintf(SelectedVsTxInfCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/Wanted_more3GeV_withCorr",iCase);
            plot(lHit->x()-xProjeInf,truthSelected,    titleSelected,-2000.,2000.,200);
            plot(lHit->x()-xProjeCorrected,truthSelectedCorrected,    titleSelectedCorrected,-2000.,2000.200);
            plot2D(tx_inf,lHit->x()-xProjeInf,SelectedVsTxInf,   titleSelectedVsTxInf,-0.6,0.6,-2000.,2000.,200,300);
            plot2D(tx_inf,lHit->x()-xProjeCorrected,  titleSelectedVsTxInfCorrected,-0.6,0.6,-400.,400.,200,300);
            
            sprintf(x0Vstx,"L0Selection/HighMomentum/Case%i/X0VsTx/Wanted_more3GeV",iCase);
            plot2D(x0,tx_inf,x0Vstx,titlex0Vstx , -8000. , 8000., -0.6,0.6,300,200);
          }
          if(part->p()>500.){
            sprintf(truthSelected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/Wanted_more500MeV",iCase);
            sprintf(truthSelectedCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/Wanted_withCorr_more500MeV",iCase);
            sprintf(SelectedVsTxInf,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/Wanted_more500MeV",iCase);
            sprintf(SelectedVsTxInfCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/Wanted_more500MeV_withCorr",iCase);
            plot(lHit->x()-xProjeInf,truthSelected,    titleSelected,-2000.,2000.,200);
            plot(lHit->x()-xProjeCorrected,truthSelectedCorrected,    titleSelectedCorrected,-2000.,2000.200);
            plot2D(tx_inf,lHit->x()-xProjeInf,SelectedVsTxInf,   titleSelectedVsTxInf,-0.6,0.6,-2000.,2000.,200,300);
            plot2D(tx_inf,lHit->x()-xProjeCorrected,  titleSelectedVsTxInfCorrected,-0.6,0.6,-400.,400.,200,300);
            
            sprintf(x0Vstx,"L0Selection/HighMomentum/Case%i/X0VsTx/Wanted_more500Mev",iCase);
            plot2D(x0,tx_inf,x0Vstx,titlex0Vstx , -8000. , 8000., -0.6,0.6,300,200);
          }
        }
      }
      if(!assoc2Hit){
        sprintf(truthSelected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/NotAssociated",iCase);
        sprintf(truthSelectedCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjection/NotAssociated",iCase);
        sprintf(SelectedVsTxInf,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/NotAssociated_withCorr",iCase);
        sprintf(SelectedVsTxInfCorrected,"L0Selection/HighMomentum/Case%i/DeltaHitProjectionVsTxInf/NotAssociated_withCorr",iCase);
        plot(lHit->x()-xProjeInf,truthSelected,    titleSelected,-2000.,2000.,200);
        plot(lHit->x()-xProjeCorrected,truthSelectedCorrected,    titleSelectedCorrected,-2000.,2000.200);
        plot2D(tx_inf,lHit->x()-xProjeInf,SelectedVsTxInf,   titleSelectedVsTxInf,-0.6,0.6,-2000.,2000.,200,300);
        plot2D(tx_inf,lHit->x()-xProjeCorrected,  titleSelectedVsTxInfCorrected,-0.6,0.6,-400.,400.,200,300);
        sprintf(x0Vstx,"L0Selection/HighMomentum/Case%i/X0VsTx/NotAssociated",iCase);
        plot2D(x0,tx_inf,x0Vstx,titlex0Vstx , -8000. , 8000., -0.6,0.6,300,200);
      }
#endif
      for (PrHitZone* xZone : {m_zones[s_T2X1 | part], m_zones[s_T2X2 | part]}) {
        double xProjected = x0 + xZone->z(0.)*tx_pickedcombination;
        bool is7 = xZone->planeCode()==7;
        if(is7) CorrX0 = Parameters_Seed7[6]*x0;
        double xProjectedCorrected = xProjected+CorrX0;
        double max = 0.;
        double min = 0.;
        if(is7){
          x0new = x0*(1.+Parameters_Seed7[6]);
          if(std::fabs(x0)>0. && std::fabs(x0)<Parameters_Seed7[1] ){ //linear cut in high momentum region
            max = Parameters_Seed7[0];
            min = -1*Parameters_Seed7[0];
          }
          if(std::fabs(x0)>Parameters_Seed7[1] && std::fabs(x0)<Parameters_Seed7[2]){
            max = Parameters_Seed7[0];
            min = -1*Parameters_Seed7[5]+ (-1.*Parameters_Seed7[0] - (-1.*Parameters_Seed7[5] ))*( std::fabs(x0)-Parameters_Seed7[3])/(Parameters_Seed7[1] - Parameters_Seed7[3]);
          }
          if(std::fabs(x0)>Parameters_Seed7[2] && std::fabs(x0)<Parameters_Seed7[3])
          {
            max = Parameters_Seed7[4] + (Parameters_Seed7[0] - Parameters_Seed7[4])*(std::fabs(x0) - Parameters_Seed7[3] )/(Parameters_Seed7[2] - Parameters_Seed7[3]);
            min =  min = -1*Parameters_Seed7[5]+ (-1.*Parameters_Seed7[0] - (-1.*Parameters_Seed7[5] ))*( std::fabs(x0)-Parameters_Seed7[3])/(Parameters_Seed7[1] - Parameters_Seed7[3]);
          }
          if(std::fabs(x0)>Parameters_Seed7[3]) continue;
        }
        if(!is7){
          if(std::fabs(x0)>0. && std::fabs(x0)<Parameters_Seed4[1] )
          {
            //linear cut in high momentum region                                                                                                                                                                                    
            max = Parameters_Seed4[0]; 
            min = -1*Parameters_Seed4[0];
          }
          if(std::fabs(x0)>Parameters_Seed4[1] && std::fabs(x0)<Parameters_Seed4[2])
          {                                                                                                                                                                               
            max = Parameters_Seed4[0];                                                                                                 
            min = -1*Parameters_Seed4[5]+ (-1.*Parameters_Seed4[0] - (-1.*Parameters_Seed4[5] ))*( std::fabs(x0)-Parameters_Seed4[3])/(Parameters_Seed4[1] - Parameters_Seed4[3]);  
          }                                                                                                                                
          if(std::fabs(x0)>Parameters_Seed4[2] && std::fabs(x0)<Parameters_Seed4[3])
          {
            max = Parameters_Seed4[4] + (Parameters_Seed4[0] - Parameters_Seed4[4])*(std::fabs(x0) - Parameters_Seed4[3] )/(Parameters_Seed4[2] - Parameters_Seed4[3]);
            min = -1*Parameters_Seed4[5]+ (-1.*Parameters_Seed4[0] - (-1.*Parameters_Seed4[5] ))*(std::fabs(x0)-Parameters_Seed4[3])/(Parameters_Seed4[1] - Parameters_Seed4[3]);
          }                    
          if(std::fabs(x0)>Parameters_Seed7[3]) continue;       
        }
        
        
        
        double TollerancePlus = max;
        double TolleranceMinus = min;
        // always()<<"x0"<<"\t min \t"<<"\t max \t"<<"plane"<<endmsg
        //         <<x0<<"\t"<<min<<"\t"<<max<<"\t"<<xZone->planeCode()<<endmsg;
        
        if(x0<0.)
        {
          TollerancePlus = -1.*min;
          TolleranceMinus = -1.*max;
        }
        
        
        
        // if(iCase ==1) {
        //   TollerancePlus = m_yOff1_Loose;
        //   TolleranceMinus = m_yOff2_Loose;
        // }else if(iCase == 2) {
        //   TollerancePlus = m_yOff1_Loose*2.;
        //   TolleranceMinus = m_yOff2_Loose*2.;
        // }
        
        double xMax =  xProjectedCorrected  +TollerancePlus;
        double xMin =  xProjectedCorrected  +TolleranceMinus;
        // if( x0>0. ){
        //   xMax =  xProjectedCorrected  + -TolleranceMinus;
        //   xMin =  xProjectedCorrected  + -TollerancePlus;
        // }
        if( xMax<xMin && msgLevel(MSG::DEBUG)) debug()<<"\t\t\t\t\t Wrong xMax/xMin"<<endmsg;
        if( xMax<xMin ) always() <<"Wrong xMax xMin   Case "<<iCase<<"\t Plane\t"<<xZone->planeCode() <<"\t x0 \t"<<x0<<"\t xMin \t"<<xMin <<"\t xMax \t"<<xMax<<endmsg;
        
        PrHits::iterator itH = std::lower_bound(xZone->hits().begin(), xZone->hits().end(), xMin, lowerBoundX() );
        PrHit* mHit;
        for (; xZone->hits().end() != itH; ++itH ) {
          mHit = *itH;
          if ( mHit->x() > xMax ) break;
          // we can try to avoid this test
          if ( mHit->isUsed() && m_removeFlagged) continue; //Not re use Hits in the middle 
          
          if (msgLevel(MSG::DEBUG)) debug()<<"Filling Parabola Seed Hits"<<endmsg;
          parabolaSeedHits.push_back(mHit);
        }
        if (parabolaSeedHits.size() > 0 && msgLevel(MSG::DEBUG)) debug()<<"ParabolaSeedHits Size \t ="<<parabolaSeedHits.size()<<endmsg;
        //Look for another Hit in last layer
        //end loop to pick up Hits in the 2 inner Layers (was only)
      }
      if (parabolaSeedHits.size()==0) continue;
      //if we don't fine any parabola Seed Hits in the middle 2 Layers then search for another XLast Hit
      // sort the parabola seed hits wrt to distance to the linear projection
      // merged parabolaSeedHits T2-1 & T2-2
      //=======================================================
      // We have 1 Hit in 1st 1 Hit in last and a
      // vector of Hits for in-between
      //=======================================================
      //std::vector<PrHits> xHitsLists; //vector of list of Hits
      xHitsLists.clear();
      
      //=======================================================
      //Sort the ParabolaSeedHits for in-between layers in increasing distance from the Projected Corrected position only when we have more than 1 ParabolaSeedHit
      //=======================================================
      if(parabolaSeedHits.size()>=1)
      {
        //Principle of the Lambda funtion, Hits sorted wrt distance from linear Projection 1st-3rd layer
        std::stable_sort( parabolaSeedHits.begin(),parabolaSeedHits.end(),
                          [x0new,tx_pickedcombination](const PrHit* lhs, const PrHit* rhs)
                          ->bool{return std::fabs(lhs->x() - (x0new + lhs->z()*tx_pickedcombination)) < std::fabs(rhs->x() - (x0new + rhs->z(0)*tx_pickedcombination));} );
      }
      if (msgLevel(MSG::DEBUG)) debug()<<"The Lambda Function Sorting end"<<endmsg;
      unsigned int maxParabolaSeedHits = m_maxParabolaSeedHits;
      if(parabolaSeedHits.size()<m_maxParabolaSeedHits)
      {
        maxParabolaSeedHits = parabolaSeedHits.size();
      }
      for (unsigned int i = 0; i<maxParabolaSeedHits;++i) //build a parabola for each 3 hit combination
      {
        //if (maxParabolaSeedHits==0) break; //maybe a repetition
        double a = 0;
        double b = 0;
        double c = 0; 
        //PrHits xHits;
        xHits.clear();
        if (m_useCubic) {
          solveParabola2(fHit,parabolaSeedHits[i],lHit,a,b,c); //Extrapolation with dRatio
        } else {
          solveParabola(fHit,parabolaSeedHits[i],lHit,a,b,c); //Extrapolation without dRatio
        }
        //P Cut at 5 GeV (from MC)
        // 
        // if(abs(b) <0.4) continue;
        // if(abs(a) <4.5e-6) continue;
        if (msgLevel(MSG::DEBUG)) debug()<<"Parabola Par"
                                         <<"\n a \t"<<a
                                         <<"\n b \t"<<b
                                         <<"\n c \t"<<c<<endmsg;
        //===================================================
        // Look in all the other layers except the
        // 1st/last/zone except the parabolaSeedHit
        //===================================================
        //Loop on all the xZones
        double m_dRatio = m_dRatio0 + c * m_dRatio1 + c * c * m_dRatio2;
        //for ( std::vector<PrHitZone*>::iterator itZ = xZones.begin(); xZones.end() != itZ; ++itZ )
        for (PrHitZone* xZone : xZones) {
          if (msgLevel(MSG::DEBUG)) debug()<<"Selecting ParSeedHits"<<endmsg;

          if (xZone->planeCode() == parabolaSeedHits[i]->planeCode()) continue;
          
          double dz   = xZone->z() - m_geoTool->zReference();
          double xAtZ = a * dz * dz + b * dz + c; //Parabolic computation
          if (m_useCubic) {
            xAtZ= a * dz * dz * (1. + m_dRatio * dz) + b * dz + c; //with Cubic Correction
          }
          double xMaxAtZ = xAtZ + m_maxDeltaPar;   //std::fabs(tx_pickedcombination)+0.5;
          double xMinAtZ = xAtZ - m_maxDeltaPar;     //std::fabs(tx_pickedcombination)-0.5;
          if (iCase == 1) {
            xMaxAtZ = xAtZ + m_maxDeltaPar_Loose;
            xMinAtZ = xAtZ - m_maxDeltaPar_Loose;
          } else if (iCase == 2) {
            xMaxAtZ = xAtZ +m_maxDeltaPar_Loose;
            xMinAtZ = xAtZ -m_maxDeltaPar_Loose;
          }
          
          
          //Best projected Hit
          PrHit* bestProj = nullptr;
          double  bestDist = m_maxDeltaPar; //2.0 mm at the moment (Larger)? tighter? (see offline Seeding)
          if (iCase == 1) {
            bestDist = m_maxDeltaPar_Loose*1.5;
          } else if (iCase == 2 ) {
            bestDist = m_maxDeltaPar_Loose*2.5;
          }
          
          //Loop in all the Hits in a given X Zones( here still in the loop in xZones
          //Sort Hits from xMinAtZ to greater X
          if (xMinAtZ > xMaxAtZ) {
            if (msgLevel(MSG::DEBUG)) debug()<<"Bad Settings!!!!!!"<<endmsg;
          }
          PrHits::iterator itH = std::lower_bound(xZone->hits().begin() ,xZone->hits().end(),xMinAtZ,lowerBoundX());
          PrHit* hit;
          for (; xZone->hits().end() != itH; ++itH ) {
            hit = *itH;

            if (hit->isUsed() && m_removeFlagged)  continue;
            //if (hit->x() < xMinAtZ ) continue;
            if (hit->x() > xMaxAtZ ) break;
            //Find Hit with Best distance <2.0mm
            if(std::fabs(hit->x() - xAtZ ) < bestDist) 
            {
              bestDist =std::fabs(hit->x() - xAtZ );
              if (msgLevel(MSG::DEBUG)) debug()<<"I found an Hit from projection"<<endmsg;
              bestProj = hit;
            }
          }
          
          //End Loop on the Hits in the remaining layers to pick up Hits in the closer to the parabolic projection 
          if (bestProj != nullptr)
          {
            xHits.push_back(bestProj);
          }
          //in principle i have not
          //pushing back the hit
          //which was used to
          //seed the parabola
          //at this step Hits has the inner layer parabola
          //+ extractrapolated hit &
          // & best hit wrt distance to extrapolated parabola
        }//end loop xZones
        
        if (msgLevel(MSG::DEBUG)) debug()<<"End Loop in between zones to pick up Projection of parabola"<<endmsg;
        //    xHits.push_back( parabolaSeedHits[i]);
        // Add to the xHits Vector the remaining 3 Hits not considered
        xHits.push_back( parabolaSeedHits[i]);
        xHits.push_back( fHit);
        xHits.push_back( lHit);
        
        if(xHits.size()>6)
        { 
          always()<<"Smething goes wrong!!!! in the creation of the xHits list"<<endmsg;
          always()<<"xHits is bigger than 6 : ERROR"<<endmsg;
        }
        //end parabola Seed Hits loop in other Layers
        //Still in the L0 loop (selection last layer)
        //at this step we have 1 Hit in 1st Layer
        //at this step we have 1 Hit in last Layer
        //at this step we have 1 Hit in Middle Layer
        //at this step we have Hit in remaining X layers at the
        //best distance to extrapolated parabola All of them are
        //inside xHits i want to have at least min_HitXSize
        //UNDER STUDY CASE 0 Only Keep Tracks found with 6 Hits (reduce ghost rate if add UV too
        //1st Case keep only 6 Hits on found track
        //if(iCase == 0 && (xHits.size() <m_minXPlanes)) continue;
        ////2nd Case keep tracks with 4/5/6 hits
        //if(iCase == 1 && xHits.size() <m_minXPlanes) continue;
        if( xHits.size() <  m_minXPlanes)  continue; //Require at least m_minXPlanes
        std::stable_sort(xHits.begin(), xHits.end(), compX());
        bool isEqual = false;
        //Remove xHits in the xHitsLists whicha are basically the same
        for (PrHits& hits : xHitsLists){
          if(msgLevel(MSG::DEBUG)) debug()<<"looping on xHitsLists"<<endmsg;
          if(hits == xHits){
            isEqual = true;
            break;
          }
        }
        if(!isEqual)
        { 
          if (msgLevel(MSG::DEBUG)) debug()<<"Pushing Back xHits List"<<endmsg;
          xHitsLists.push_back( xHits);
        }
      }//End loop parabolaSeedHits
      if (msgLevel(MSG::DEBUG)) debug()<<"End Loop For pick up Parabola Hits and build the xHitsLists"<<endmsg;
      //End loop Parabola Seed Hits
      //-------- Remove Duplicates from search in parabolaSeedHits
      if (msgLevel(MSG::DEBUG)) debug()<<"xHitsLists size before removing duplicates: "<<xHitsLists.size()<<endmsg;
      if (xHitsLists.size() == 0) {
        continue;
      }
      if (xHitsLists.size() > 1) {
        //---Remove Duplicates in the HitsList
        std::stable_sort( xHitsLists.begin(), xHitsLists.end() );
        xHitsLists.erase( std::unique(xHitsLists.begin(), xHitsLists.end()), xHitsLists.end());
      }
      if (msgLevel(MSG::DEBUG)) debug()<<"xHitsLists size after removing duplicates: "<<xHitsLists.size()<<endmsg;
      //Now let's fit the track
      for (PrHits& xHits : xHitsLists){ 
        if (msgLevel(MSG::DEBUG)) debug()<<"Fit Track"<<endmsg;
        //Create the track 
        PrSeedTrack2 temp_track( part , m_geoTool->zReference() , xHits); //Create the track
        //Setters for it: usefull later to parametrise 
        temp_track.setdRatio(0.);
        //I load in the track these info which are then plotted
        if(m_useCubic){
          //Maybe a dRatio = f(x(zref));//Pierre Parametrisation
          temp_track.setdRatio(m_dRatio0);
        }
        //-----------------------------------------------------
        //----------------O-_The Fit_-O------------------
        //-----------------------------------------------------
        int nIter = 0;
        bool doRefit = false;
        temp_track.setRefitX(0);
        if (msgLevel(MSG::DEBUG) ){ debug()<<"Attempting to Fit the following Track"<<endmsg; printTrack(temp_track);}
        bool OK = false;
        // if( m_useImproved)
        // {
        //   if(iCase==0 && temp_track.hits().size()>4){
        //   OK = fitXProjection(temp_track,0,iCase,doRefit);
        //   }
        // }
        
        if(temp_track.hits().size()>4 && iCase==0){
          OK = fitXProjection(temp_track , 0 , iCase ,doRefit); //Fit the track projection on the XZ plane
        }
        if(iCase==1 || iCase==2)
          OK = fitXProjection(temp_track, 0, iCase, doRefit);
        if(!OK && msgLevel(MSG::DEBUG)) 
          debug()<<"Fit Failed"<<endmsg;
        while(!OK){
          nIter++;
          if (msgLevel(MSG::DEBUG)) debug()<<"The Fit failed"<<endmsg;
          if(temp_track.hits().size() <= m_minXPlanes) break;
          temp_track.setRefitX(nIter);
          if (msgLevel(MSG::DEBUG)) debug()<<"Removing Hits and Refit"<<endmsg;
          if(m_useImproved && iCase ==0 && nIter==1 && temp_track.hits().size()==4){
            OK = false;
            break;
          }
            
          OK = removeWorstAndRefitX( temp_track, nIter , iCase,doRefit);
          if (msgLevel(MSG::DEBUG)) debug()<<"Remove worse and Refit Done"<<endmsg;
          if (msgLevel(MSG::DEBUG)) debug()<<"***"<<endmsg;
        }
        setChi2X(temp_track);
        double maxChi2PerDoF = m_maxChi2PerDoF;
        if(iCase == 0) maxChi2PerDoF = 6.5;
        if(iCase == 0 && m_useImproved) maxChi2PerDoF = 3.5;
        if( OK && 
            temp_track.hits().size() >= m_minXPlanes
            && (( temp_track.chi2PerDoF() < maxChi2PerDoF) /*||
                                                             (iCase !=0 && temp_track.chi2PerDoF() <m_maxChi2PerDoF +6*tx_pickedcombination*tx_pickedcombination)*/)){
          m_xCandidates.push_back(temp_track); //The X Candidate is created
        }
      }//end Loop xHist:xHitsLists
    }//end loop Last Zone given a firsZone selected
  }//end Loop First Zone
  std::stable_sort(m_xCandidates.begin(),m_xCandidates.end(),PrSeedTrack2::GreaterBySize());
  


  //====================================================================
  // Remove clones at this step???, i.e. share more than 2 hits (why not 3?)
  //====================================================================
  // debug()<<"Removing Clones in X Step"<<endmsg;
  if(m_xOnly && m_removeClonesX) removeClonesX(m_nCommonX);
  for( PrSeedTrack2s::iterator itT1 = m_xCandidates.begin() ; m_xCandidates.end()!=itT1;++itT1)
  {
    if( m_xOnly && (*itT1).valid() ){
      if (msgLevel(MSG::DEBUG)) debug()<<"Fillincg Container Of Tracks"<<endmsg;
      m_trackCandidates.push_back( *itT1 );
    }
  }
}


void PrHybridSeeding::removeClonesX(unsigned int maxCommon)
{
  
  for ( PrSeedTrack2s::iterator itT1 = m_xCandidates.begin(); m_xCandidates.end() !=itT1; ++itT1 ){
    if ( !(*itT1).valid() ) continue;  
    for ( PrSeedTrack2s::iterator itT2 = itT1 + 1; m_xCandidates.end() !=itT2; ++itT2 ) {
      if ( !(*itT2).valid() ) continue;
      //if(m_mapClonesX){
      int Compare = (*itT1).hits().size()*(*itT2).hits().size();
      switch(Compare)
      {
      case 36: //6 vs 6
        maxCommon = 3;
        break;
      case 30: //6 vs 5
        maxCommon = 2; 
        break;   
      case 24: //6 vs 4
        maxCommon = 1;
        break;
      case 25: //5 vs 5
        maxCommon = 2;
        break;
      case 20: //5 vs 4
        maxCommon =1;
        break;
      case 16:
        maxCommon= 1;
      }
      //}
      
      int nCommon = 0;
      PrHits::iterator itH1 = (*itT1).hits().begin();
      PrHits::iterator itH2 = (*itT2).hits().begin();
      PrHits::iterator itEnd1 = (*itT1).hits().end();
      PrHits::iterator itEnd2 = (*itT2).hits().end();
      //count number of common hits between track 1 and track 2
      while ( itH1 != itEnd1 && itH2 != itEnd2 ) {
        if ( (*itH1)->id() == (*itH2)->id() ) {
          ++nCommon;
          ++itH1;
          ++itH2;
        }else if( (*itH1)->id() < (*itH2)->id() ) {
          ++itH1;
        }else {
          ++itH2;
        }
      }
      if ( nCommon >= maxCommon ) {
        if ( (*itT1).hits().size() > (*itT2).hits().size() ) {
          (*itT2).setValid( false );
        } else if ( (*itT1).hits().size() < (*itT2).hits().size() ) {
          (*itT1).setValid( false );
        } else if ( (*itT1).chi2PerDoF() < (*itT2).chi2PerDoF() ) {
          (*itT2).setValid( false );
        } else {
          (*itT1).setValid( false );
        }
      }
    }
  }
}




void PrHybridSeeding::removeClones(unsigned int maxCommon)
{
  
  for ( PrSeedTrack2s::iterator itT1 = m_trackCandidates.begin(); m_trackCandidates.end() !=itT1; ++itT1 ){
    if ( !(*itT1).valid() ) continue;
    for ( PrSeedTrack2s::iterator itT2 = itT1 + 1; m_trackCandidates.end() !=itT2; ++itT2 ) {
      if ( !(*itT2).valid() ) continue;
      int nCommonUV = 0;
      int nCommon = 0;
      int MaxCommonUV = 0;
      PrHits::iterator itH1 = (*itT1).hits().begin();
      PrHits::iterator itH2 = (*itT2).hits().begin();
      PrHits::iterator itEnd1 = (*itT1).hits().end();
      PrHits::iterator itEnd2 = (*itT2).hits().end();
      PrPlaneCounter2 Tr1;
      Tr1.set(itH1, itEnd1);
      PrPlaneCounter2 Tr2;
      Tr2.set(itH2,itEnd2);
      while ( itH1 != itEnd1 && itH2 != itEnd2 ) {
        if ( (*itH1)->id() == (*itH2)->id() ) {
          if(!(*itH1)->isX() ) ++nCommonUV;
          ++nCommon;
          ++itH1;
          ++itH2;
        }else if( (*itH1)->id() < (*itH2)->id() ) {
          ++itH1;
        }else {
          ++itH2;
        }
      }
      int Tr1DiffUV = Tr1.nbDifferentUV();
      int Tr2DiffUV = Tr2.nbDifferentUV();
      int Compare = Tr1DiffUV * Tr2DiffUV;
      int maxCommonUV = 1;
      switch(Compare)
      {
      case 36:
        maxCommonUV = 3;
        break;
      case 30:
        maxCommonUV = 2;
        break;
      case 24:
        maxCommonUV = 1;
        break;
      case 25:
        maxCommonUV = 2;
        break;
      case 16:
        maxCommonUV = 1;
      }
      if (nCommonUV>=maxCommonUV){
        if(Tr1.nbDifferent() > Tr2.nbDifferent()){
          (*itT1).setValid( false) ;
        }
        if(Tr2.nbDifferent() < Tr2.nbDifferent())
        {
          (*itT2).setValid( false);
        }
        else if((*itT1).chi2PerDoF() < (*itT2).chi2PerDoF()){
          (*itT2).setValid(false);
        } else 
        {
          (*itT1).setValid(false);
        }
      
      
      
        // if ( nCommon > maxCommon ) {
        //   if ( (*itT1).hits().size() > (*itT2).hits().size() ) {
        //     (*itT2).setValid( false );
        //   } else if ( (*itT1).hits().size() < (*itT2).hits().size() ) {
        //     (*itT1).setValid( false );
        //   } else if ( (*itT1).chi2PerDoF() < (*itT2).chi2PerDoF() ) {
        //     (*itT2).setValid( false );
        //   } else {
        //     (*itT1).setValid( false );
        //   }
      }
    }
  }
}


void PrHybridSeeding::flagHits(unsigned int icase)
{
  /*Standard Flagg*/
  
  for (PrSeedTrack2& track : m_trackCandidates){
    if (!track.valid()) continue;
    if(track.hits().size()<m_SizeFlag) continue;
     
    for (PrHit* hit : track.hits()) {
      if(track.chi2(hit) < m_MaxChi2Flag && track.X0() <m_MaxX0Flag)
      {
        hit->setUsed(true);
      }
    }
  }
}

//=========================================================================
//  Convert to LHCb tracks
//=========================================================================
void PrHybridSeeding::makeLHCbTracks ( LHCb::Tracks* result ) {
  for ( PrSeedTrack2s::iterator itT = m_trackCandidates.begin();m_trackCandidates.end() != itT; ++itT ) {
    if ( !(*itT).valid() ) continue;
    if ( msgLevel(MSG::DEBUG) ) debug()<<"Creating LHCb Track"<<endmsg;
    
    LHCb::Track* tmp = new LHCb::Track;
    tmp->setType( LHCb::Track::Ttrack );
    tmp->setHistory( LHCb::Track::PrSeeding );
    double qOverP = m_geoTool->qOverP( *itT );
    LHCb::State tState;
    double z = StateParameters::ZEndT;
    tState.setLocation( LHCb::State::AtT );
    tState.setState( (*itT).x( z ), (*itT).y( z ), z, (*itT).xSlope( z ), (*itT).ySlope( ), qOverP );

    //== overestimated covariance matrix, as input to the Kalman fit

    tState.setCovariance( m_geoTool->covariance( qOverP ) );
    tmp->addToStates( tState );

    //== LHCb ids.

    tmp->setPatRecStatus( LHCb::Track::PatRecIDs );
    for ( PrHits::iterator itH = (*itT).hits().begin(); (*itT).hits().end() != itH; ++itH ) {
      tmp->addToLhcbIDs( (*itH)->id() );
    }
    tmp->setChi2PerDoF( (*itT).chi2PerDoF() );
    tmp->setNDoF(       (*itT).nDoF() );
    result->insert( tmp );
  }
}






void PrHybridSeeding::solveParabola(const PrHit* hit1, const PrHit* hit2, const PrHit* hit3, double& a, double& b, double& c){
  const double x3 = hit3->x();

  //New Parabola Method (be adapted to new parametrisation)
  const double z1_PB = hit1->z() - hit3->z();
  const double z2_PB = hit2->z() - hit3->z();
  const double x1_PB = hit1->x() - hit3->x();
  const double x2_PB = hit2->x() - hit3->x();

  const double det_PB = z1_PB*z2_PB*(z1_PB-z2_PB);

  if( std::fabs(det_PB) < 1e-8 ){
    a = 0.0;
    b = 0.0;
    c = 0.0;
    return;

  }

  a=0; b=0;c=0;
  a = (z2_PB*x1_PB-z1_PB*x2_PB)/det_PB;
  b = (-z2_PB*z2_PB*x1_PB+z1_PB*z1_PB*x2_PB)/det_PB;
  const double z3_PB = hit3->z() - m_geoTool->zReference();
  c = x3 + a * z3_PB * z3_PB - b *z3_PB;
  b -= 2 * a * z3_PB;
}

void PrHybridSeeding::solveParabola2(const PrHit* hit1,const PrHit* hit2,const PrHit* hit3,double& a1, double& b1,double& c1){
  const double z1 = hit1->z() - m_geoTool->zReference();
  const double z2 = hit2->z() - m_geoTool->zReference();
  const double z3 = hit3->z() - m_geoTool->zReference();
  const double x1 = hit1->x();
  const double x2 = hit2->x();
  const double x3 = hit3->x();
  //const double e = m_dRatio;
  const double corrZ1 = 1+m_dRatio0*z1;
  const double corrZ2 = 1+m_dRatio0*z2;
  const double corrZ3 = 1+m_dRatio0*z3;
  const double det = (z1*z1)*corrZ1*z2 + z1*(z3*z3)*corrZ3 + (z2*z2)*corrZ2*z3 - z2*(z3*z3)*corrZ3 - z1*(z2*z2)*corrZ2 - z3*(z1*z1)*corrZ1;
  if( std::fabs(det) < 1e-8 )
  {
    a1 = 0.0;
    b1 = 0.0;
    c1 = 0.0;
    return;
  }
  const double det1 = (x1)*z2 + z1*(x3) + (x2)*z3 - z2*(x3) - z1*(x2) - z3*(x1);
  const double det2 = (z1*z1)*corrZ1*x2 + x1*(z3*z3)*corrZ3 + (z2*z2)*corrZ2*x3 - x2*(z3*z3)*corrZ3 - x1*(z2*z2)*corrZ2 - x3*(z1*z1)*corrZ1;
  const double det3 = (z1*z1)*corrZ1*z2*x3 + z1*(z3*z3)*corrZ3*x2 + (z2*z2)*corrZ2*z3*x1 - z2*(z3*z3)*corrZ3*x1 - z1*(z2*z2)*corrZ2*x3 - z3*(z1*z1)*corrZ1*x2;
  a1 = det1/det;
  b1 = det2/det;
  c1 = det3/det;
}

//=========================================================================
//  Fit the track, return OK if fit sucecssfull
//=========================================================================
bool PrHybridSeeding::fitSimultaneouslyXY( PrSeedTrack2& track ,int refit, unsigned int iCase) {
  double mat[15];
  double rhs[5];
  int nHitsX;
  int nHitsStereo;
  double a = track.ax();
  double  m_dRatio = m_dRatio0+m_dRatio1*a+m_dRatio2*a*a;
  
  double zRef = m_geoTool->zReference();
  for ( int loop = 0; 3 > loop ; ++loop ) {
    if(loop ==1 ){                                                                                                       
      double RadiusPosition = std::sqrt( (track.ax()*track.ax()*std::fabs(track.ax())/2000.) +
                                         (track.y(zRef)*track.y(zRef)*std::fabs(track.y(zRef))/1000.));
      double RadiusSlopes = std::sqrt( track.bx()*track.bx()*std::fabs(track.bx())/0.3 +
                                       track.by()*track.by()*std::fabs(track.by())/0.1   );  
      double dRatioPos = - ( 2.622e-4 +1.943e-8*RadiusPosition + 1.08e-11*RadiusPosition*RadiusPosition);
      double dRatioSlopes = - ( 2.6098e-4+ 6.31e-5*RadiusSlopes  -0.000156778*RadiusSlopes*RadiusSlopes + 0.000134126*RadiusSlopes*RadiusSlopes*RadiusSlopes);
      if(m_useCorrPos){
        track.setdRatio(dRatioPos);
        m_dRatio = dRatioPos;
      }
      if(m_useCorrSlopes){                                              
        track.setdRatio(dRatioSlopes);
        m_dRatio = dRatioSlopes;
      }
    }
    std::fill(mat,mat+15,0.); 
    std::fill(rhs,rhs+5,0.);
    double z0 = m_geoTool->zReference(); 
    //std::fill(mat, mat + 20, 0.);
    nHitsX = 0, nHitsStereo = 0;
    for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ) 
    {
      if( (*itH)->isX()) 
      {
        nHitsX++;
      }else  nHitsStereo++;
      const double w = (*itH)->w();
      const double dxdy = (*itH)->dxDy();
      const double dz =((*itH)->z() - z0);
      double deta = 0.;
      if(m_useCubic){
        deta = dz*dz*(1+m_dRatio*dz);
      }
      else deta = dz*dz;
      const double wdz = w * dz;
      const double eta = dz * dz * (1. + dz * m_dRatio);
      const double weta = w * deta;
      const double wdxdy = w * dxdy;
      const double wdxdydz = wdxdy * dz;
      const double dist = track.distance( *itH );
      //Fill Matrix
      mat[0] += w;
      mat[1] += wdz; mat[2] += wdz * dz;
      mat[3] += weta; mat[4] += weta * dz; mat[5] += weta * eta; 
      mat[6] -= wdxdy;mat[7] -= wdxdydz;   mat[8] -= wdxdy * deta;  mat[9] += wdxdy * dxdy;
      mat[10] -= wdxdydz; mat[11] -= wdxdydz * dz;  mat[12] -= wdxdydz * deta;  mat[13] += wdxdydz * dxdy; mat[14] += wdxdydz * dz * dxdy;
      
      // fill right hand side
      rhs[0] += w * dist;
      rhs[1] += wdz * dist;
      rhs[2] += weta * dist;
      rhs[3] -= wdxdy * dist;
      rhs[4] -= wdxdydz * dist;
    }//Loop over Hits to fill the matrix
    // decompose matrix, protect against numerical trouble
    if(nHitsX < 4 || nHitsStereo < 4) return false;
    ROOT::Math::CholeskyDecomp<double, 5> decomp(mat);
    if (!decomp) return false;
    decomp.Solve(rhs);
    //double yAtZRef = rhs[3];
    rhs[3] -= rhs[4] * z0; // ???? this should be here only if the track y part is ay + b_y*(z-zref);
    // if (std::abs(rhs[0]) > 1e4 || std::abs(rhs[1]) > 5. ||
    //     std::abs(rhs[2]) > 1e-3 || std::abs(rhs[3]) > 1e4 ||
    //     std::abs(rhs[4]) > 1.) return false;
    track.updateParameters(rhs[0],rhs[1],rhs[2],rhs[3],rhs[4]);
  }
  
  double chi2_track = 0.;
  double maxChi2 =0.;
  // double maxDistance = 0.;
  // double absdistanceSum = 0.;
  // double distanceSum = 0;
  // unsigned int NHits = (unsigned int)track.hits().size();
  //PrHit *worst = nullptr;
  for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ) 
  {
    double chi2_onHit = track.chi2( *itH);
    chi2_track+=chi2_onHit;
    if ( track.chi2(*itH) > maxChi2 )
    { 
      maxChi2 = chi2_onHit;
      //worst = *itH;
    }
  }//Set Max Chi2DoF
  double X0 = track.ax() - track.bx()*m_geoTool->zReference()+track.cx()*m_ConstC;
  track.setMaxChi2(maxChi2);
  if(iCase ==0 && m_useImprovedStereo){
    if(maxChi2<5.5);
    double rad = std::sqrt( ( track.y(0.)*track.y(0.) /(20.*20.) + X0*X0/(150*150) ));
    //if(track.hits().size()==9 &&  MaxChi2_fullFitCase0<1. && rad <1 ) return true;
    //if(track.hits().size();
    //if(maxChi2>5.5) return false;
    //if
    //return true;
    //}
  }
  
  if(iCase ==0 && !m_useImprovedStereo && maxChi2>6.0) return false;
  if(iCase == 2 && (track.hits().size()==9 || track.hits().size()==8 )&& std::abs(track.xPredT1())>500. &&chi2_track< (4.+(std::abs(track.xPredT1())-500.)*20./2000.)) return true;
  if(iCase == 2 && (track.hits().size()==9 || track.hits().size()==8 )&& std::abs(track.xPredT1())<500.) return false;
  if(iCase == 1 && track.hits().size()==8 && chi2_track<(2.5-std::fabs(track.y(zRef))*2.5/500.)) return true;
  if(iCase == 1 && track.hits().size()==8 && chi2_track>(2.5-std::fabs(track.y(zRef))*2.5/500.)) return false;
  if(iCase == 1 && track.hits().size()==10 && chi2_track< 5-std::fabs(track.y(zRef))*5./2000.) return true;
  if(iCase == 1 && track.hits().size()==10 && chi2_track>5-std::fabs(track.y(zRef))*5./2000.) return false;
  if(iCase == 1 && track.hits().size()==9 && chi2_track<(2.5-std::fabs(track.y(zRef))*2.5/500.)) return true;
  if(iCase == 1 && track.hits().size()==9 && chi2_track>(2.5-std::fabs(track.y(zRef))*2.5/500.)) return false;

  if(!m_useImproved){
    if(iCase == 0 && chi2_track< 7-std::fabs(track.y(zRef))*7./500. && std::fabs(track.X0())<500.) return true;
    if(iCase == 0 && track.hits().size()==10 && (refit == 1 || refit ==2 || refit==3 || refit==4 ) && chi2_track<4 && chi2_track < 6-std::fabs(track.y(zRef))*6./1700.) return true;
    if(iCase == 0) return false;
  }
  
  //P>5000
  // if(m_useImproved
  
  //  if(m_useImprovedStereo && iCase == 0){
  //   PrPlaneCounter plCount;
  //   plCount.set(track.hits().begin(),track.hits().end());
  //   if( plCount.nbSingleX() == 4 && plCount.nbSingleUV() != plCount.nbDifferentUV() && plCount.nbDifferentUV() < 5) return false;
  //   if( plCount.nbDifferentX() == 5 && plCount.nbSingleUV() != plCount.nbDifferentUV())
  //     return false;
  //   if( plCount.nbSingleX() == 6 && plCount.nbDifferentUV!= plCount.nbDifferentUV) return false;
  //   if( maxChi2 >6.) return false;
  // }
  

  if(m_useImproved){
    double zT1 = (m_zones[s_T1U]->z()+m_zones[s_T1V]->z())/2.;
    //double zT2 = (m_zones[s_T2U]->z()+m_zones[s_T2V]->z())/2.;
    double zT3 = (m_zones[s_T3U]->z()+m_zones[s_T3V]->z())/2;
    int region = -1;
    if( std::fabs(track.x(zT1))<=500. && std::fabs(track.y(zT1))<=500. )
      region = 0;
    if ( std::fabs(track.x(zT1))>500.  && std::fabs(track.y(zT1))<=500.)
      region = 1;
    if( std::fabs(track.x(zT1))<=500. && std::fabs(track.y(zT1))>500.)
      region = 2;
    if( std::fabs(track.x(zT1))>500. && std::fabs(track.y(zT1))> 500.) 
      region = 3;
    int nhits = track.hits().size();
    bool selected = false;
    if(iCase==0){
      if(refit>5) return false;
      if(refit==0 || refit ==1 || refit >=2){
        if(track.hits().size()>12 && chi2_track<7-std::fabs(track.y(zRef)*7./500 && std::fabs(X0)<500.)) return true; //?
        if(region ==0){
          if(refit==0){
          if(track.hits().size()==10 && chi2_track<(3.4-std::fabs(X0)*3.4/500)) return true;
          if(track.hits().size()==11 && chi2_track<4.) return true;
          if(track.hits().size()==12 && chi2_track<5.) return true;
          return false;
          }
          if(refit==1){
            if(track.hits().size()==10 && chi2_track<(8.-std::fabs(track.y(0.))*8./20.)) return true;
            if(track.hits().size()==11 && chi2_track<4.5) return true;
            if(track.hits().size()==12 && chi2_track<4.5) return true;
            return false;
          }
          if(refit==2 || refit==3){
            if(chi2_track<3.5 && std::fabs(track.y(0.))<20) return true;
            if(track.hits().size()==11 && chi2_track<4 && std::fabs(track.y(0.))<20) return true;
            return false;
          }
          if(refit==4){
            if(chi2_track<(4-std::fabs(X0)*4./100.))
              return true;
          return false;
          }
          if(refit>4)
          {
          if(chi2_track<1.5) return true;
          return false;
          }
          // if(refit==4 && track.hits().size()==12)
          // {
          //   if(chi2_track<4) return true;
          //   return false;
          // }
          // if(refit>4 && track.hits().size()==12)
          // {
          //   if(chi2_track<2) return true;
          //   return false;
          // }
          return false;
        }
        //Region 1
        if(region ==1){
          if(refit==0 && chi2_track<20.) return true;
          if(refit==1){
            if((track.hits().size()==10 || track.hits().size()==11) && chi2_track<3.) return true;
            if(track.hits().size()>=12 && chi2_track<5.) return true;
            return false;
          }
          if(refit==2){
            if(chi2_track<4) return true;
            return false;
          }
          if(refit>2){
            if(track.hits().size()>=12 && chi2_track<4) return true;
            if(track.hits().size()==11 && chi2_track<7 && std::fabs(track.y(0.))<25.) return true;
            if(track.hits().size()==10 && chi2_track<2. ) return true;
            return false;
          }
          return false;
        }
        if(region ==2){
          if(refit==0){
            if(track.hits().size()>=12 && std::fabs(track.y(0.))<50 && chi2_track <10) return true; //ok for 12 hits
            if(track.hits().size()==11 && std::fabs(track.y(0.))<50 && chi2_track <10) return true;
            if(track.hits().size()==10 && std::fabs(track.y(0.))<50 && chi2_track<4) return true;
            return false;
          }
          PrPlaneCounter2 plCount;
          plCount.set(track.hits().begin(),track.hits().end());
          if(refit==1){
            if(track.hits().size()==10 && chi2_track<3 && std::fabs(track.y(0.))<25 && plCount.nbDifferentUV()>4) return true;
            if(track.hits().size()==11 && chi2_track<3 && std::fabs(track.y(0.))<50) return true;
            if(track.hits().size()>=12 && chi2_track<3 && std::fabs(track.y(0.))<100) return true;
            return false;
          }
          if(refit==2){
            if(track.hits().size()==10 && chi2_track<3 && (std::fabs( track.y(0.) ) < 20.) && std::fabs(track.ay())<1500 && plCount.nbDifferentUV()>4) return true;
            if(track.hits().size()==11 && chi2_track<3 && std::fabs(track.y(0.))<20) return true;
            if(track.hits().size()>=12 && chi2_track<6 ) return true;
            return false;
          }
          if(refit>2){
            if(track.hits().size()==10 && chi2_track<3 && std::fabs(track.y(0.))<50 && std::fabs(track.y(zT3))<1000 && plCount.nbDifferentUV()>4) return true;
            if(track.hits().size()==11 && chi2_track<3 && std::fabs(track.y(0.))<25) return true;
            if(track.hits().size()>=12 && chi2_track<4) return true;
            return false;
          }
          return false;
        }
        if(region ==3){
          if(refit == 0 && chi2_track<(100.-std::fabs(track.y(0.))*100./50)) return true;
          if(refit == 1 && chi2_track<5. && std::fabs(track.y(0.))<50.) return true;
          if(refit == 2 && chi2_track<8. && std::fabs(track.y(0.))<100.) return true;
          if(refit>2){
            if(track.hits().size()==10 && chi2_track<4 && std::fabs(track.y(0.))<50.) return true;
            if(track.hits().size()==11 && chi2_track<8.) return true;
            if(track.hits().size()>=12 && chi2_track<8.) return true;
            return false;
          }
          return false;
        }
        return false;
      }
      return false;
    }
    if(iCase==0) always()<<"Not All cases are treated!!!! \t region"<<region<<"Size"<<track.hits().size()<<"Refit"<<refit<<endmsg;
  }
  
  
  if ( m_maxChi2HitsX > maxChi2){
    return true;  
  }
  return false;
}
//=======================================
//Fit Only X Projection
//=======================================

bool PrHybridSeeding::fitXProjection(PrSeedTrack2& track , int Refit, unsigned int iCase , bool& dorefit)
{
  if (msgLevel(MSG::DEBUG)) debug()<<"Fitting"<<endmsg;
  if(track.hits().size()<m_minXPlanes && iCase!=10) return false;
  double mat[6]; 
  double rhs[3];
  for(int loop = 0;3>loop;++loop)
  {
    std::fill(mat,mat+6,0.); 
    std::fill(rhs,rhs+3,0.);
    for( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ){
      const double w = (*itH)->w();//squared
      const double dz= ((*itH)->z() - m_geoTool->zReference());
      double deta = 0;
      if(m_useCubic)
      {
        deta = dz*dz*(1+track.dRatio()*dz);
      }else{
        deta = dz*dz;
      }
      double dist = track.distance( *itH );
      if (msgLevel(MSG::DEBUG)) debug()<<"Loop \t"<<loop<<"\n Distance From Hit \t"<<dist<<endmsg;
      mat[0]+= w;   
      mat[1]+= w * dz;   mat[2]+= w * dz * dz;
      mat[3]+= w * deta; mat[4]+= w * dz * deta;  mat[5]+= w * deta * deta;
      rhs[0]+= w * dist;
      rhs[1]+= w * dist * dz;
      rhs[2]+= w * dist * deta;
    }

    ROOT::Math::CholeskyDecomp<double,3> decomp(mat);
    if(!decomp)
    {
      return false;
    }
    //Solve linear system
    decomp.Solve(rhs);
    if (msgLevel(MSG::DEBUG)) debug()<<"Loop \t"<<loop<<"\n a = \t"<<rhs[0]<<"\n b = \t"<<rhs[1]<<"\n c = \t"<<rhs[2]<<endmsg;
    // protect against unreasonable track parameter corrections
    // (check that out)
    if(std::abs(rhs[0]) > 1e4 || std::abs(rhs[1]) > 5. ||
       std::abs(rhs[2]) > 1e-3 ) return false;
    //Small corrections
    track.updateParameters(rhs[0],rhs[1],rhs[2],0.,0.);
    double m_dRatio = m_dRatio0+rhs[0]*m_dRatio1+m_dRatio2*rhs[0]*rhs[0];
    track.setdRatio(m_dRatio);
    //Put back later faster maybe
    if (loop >0 && std::abs(rhs[0]) < 5e-3 && std::abs(rhs[1]) < 5e-6 &&
        std::abs(rhs[2]) < 5e-9) {
      break;
    }
  }
  //Compute some values on the track
  double chi2_track = 0.;
  double maxChi2 = 0.;
  unsigned int NHits = (unsigned int)track.hits().size();
  PrHit *worst= nullptr;
  for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH )  //Loop over all hits in PrSeedTrack2
  {
    double chi2_onHit = track.chi2( *itH );
    chi2_track += track.chi2( *itH );
    if ( chi2_onHit > maxChi2 ){
      maxChi2 = chi2_onHit;
      worst = *itH;
    }
  }
  
  double X0 = track.ax() - track.bx()*m_geoTool->zReference()+track.cx()*m_ConstC;
  track.setX0(X0);
  track.setMaxChi2(maxChi2);
  if(iCase==10){
    double m_maxChi2Hit = 8.;
    double m_maxX0Track = 1500.;
    double m_maxChi2Offset = 0.5;
    double m_maxX0Offset = 30.;
    double m_Cut = 400.;
    if(maxChi2 > m_maxChi2Hit) return false;
    if(std::fabs(X0)> m_maxX0Track) return false;
    if( (maxChi2-m_maxChi2Offset)*(std::fabs(X0)-m_maxX0Offset)<m_Cut){
      return true;
    }
    return false;
  }
  
  //iCase == 0 *best selected 6_0_Case0
  //Fist Fit Conditions 6 Hits
  bool selectedOld = maxChi2<5.5;
  
  bool selected6_0 = (
                      std::fabs(X0)< (850.-maxChi2*(850./6.5)) && 
                      Refit ==0 &&
                      track.hits().size()==6
                      );
  
  //--------------------------------------Case 0 
  //--------------------------------------1st Fit
  bool selected6_0_Case0 = (
                            iCase ==0 &&
                            Refit==0 &&
                            track.hits().size()==6 &&
                            std::fabs(X0) < 650 &&
                            maxChi2<8.5 &&
                            (maxChi2-0.0)*(std::fabs(X0)-30)<800);//selection  
  bool selected5_0_Case0 = (
                            iCase == 0 &&
                            Refit == 0 &&
                            track.hits().size()==5 &&
                            std::fabs(X0)< (300.-maxChi2*(300./1.5))); //selection
  
  bool selected4_0_Case0 = (
                            iCase==0 &&
                            Refit == 0 && 
                            track.hits().size()==4
                            && false); //remove all of them
  //---------------------------------------Refit
  //Case0 ReFit
  bool selected5_1_Case0 =  (
                             iCase ==0 &&
                             Refit==1 &&
                             track.hits().size()==5 &&
                             maxChi2<2.5-std::fabs(X0)*2.5/400.);//selection

  
  
  bool selected4_1_Case0 = (
                            iCase==0 &&
                            Refit==1 &&
                            track.hits().size()==4 && 
                            maxChi2<(0.15-std::fabs(X0)*0.15/40.)); //selection
  //---------------------------------------ReReFit
  //Case0 ReRefit
  bool selected4_2_Case0 = (
                            iCase == 0 &&
                            Refit==2 &&
                            (track.hits().size()==4) &&
                            maxChi2<(0.15-std::fabs(X0)*0.15/40.)); //selection
  
  
  //------------------------------------Case 1
  //Case 1 1stFit
  bool selected6_0_Case1 =  (
                             /*iCase ==1 &&*/
                             Refit==0 &&
                             track.hits().size()==6 &&
                             maxChi2 < 8.5 && 
                             (maxChi2-2.)*(std::fabs(X0)-110.)<300.);//selection
  
  bool selected5_0_Case1 = (
                            /*iCase ==1 &&*/
                            Refit == 0 &&
                            track.hits().size()==5 &&
                            maxChi2<5.5-std::fabs(X0)*5.5/500. ); //selection
  
  bool selected4_0_Case1 = (
                            /*iCase ==1 &&*/
                            Refit==0 &&
                            track.hits().size()==4 &&
                            maxChi2<0.5-std::fabs(X0)*0.5/225); //selection
  //Case1 ReFit
  bool selected5_1_Case1 = (
                            /*iCase ==1 && */
                            Refit ==1 &&
                            track.hits().size()==5 &&
                            maxChi2<2.5); //selection
  
  bool selected4_1_Case1 = ( //remove all of them?
                            iCase == 1 &&
                            Refit ==1 &&
                            false &&
                            track.hits().size()==4);
  bool selected4_2_Case1 = (
                            /*iCase==1 &&*/
                            Refit==2 &&
                            track.hits().size()==4 &&
                            std::fabs(X0) > 900 && maxChi2<5.5 ); //sele


  // if(m_useImproved)
  // {
  //   double zT1 = (m_zones[s_T1U]->z()+m_zones[s_T1V]->z())/2.;
  //   double zT2 = (m_zones[s_T2U]->z()+m_zones[s_T2V]->z())/2.;
  //   double zT3 = (m_zones[s_T3U]->z()+m_zones[s_T3V]->z())/2.;    
  //   selected6_0_Case0 = (
  //                        track.hits().size() == 6 &&
  //                        iCase == 0 &&
  //                        Refit == 0 &&
  //                        (
  //                         (   std::fabs(track.x(zT1) <500    && maxChi2<1.7 - std::fabs(X0)*1.7/150.) ) ||
  //                         (   std::fabs(track.x(zT1) >=500 && maxChi2<1.7 - std::fabs(X0)*1.7/340.) )
  //                         )
  //                        );
  //   selected5_0_Case0 = (
  //                        track.hits().size() == 5 && 
  //                        iCase == 0 &&
  //                        Refit==0 &&
  //                        (
  //                         (   std::fabs(track.x(zT1) <500    && maxChi2<1.7 - std::fabs(X0)*1.7/150.) ) ||
  //                         (   std::fabs(track.x(zT1) >=500    && maxChi2<1.7 - std::fabs(X0)*1.7/340.))
  //                         )
  //                        );  
  //   selected5_1_Case0 = (
  //                        iCase == 0 &&
  //                        Refit==1 &&
  //                        track.hits().size()==5 && 
  //                        (
  //                         (    std::fabs(track.x(zT1)) <500.  && maxChi2<(1.7 - std::fabs(1.7/340)) ) ||
  //                         (    std::fabs(track.x(zT1)) >=500.  && maxChi2<(3.0 - std::fabs(X0)*3./600) )
  //                         )
  //                        ); 
  //   selected4_2_Case0 = (
  //                        iCase == 0 && 
  //                        Refit==2 &&
  //                        track.hits().size() == 4 && 
  //                        (
  //                         ( std::fabs(track.x(zT1))> 400. && std::fabs(X0)>100 && maxChi2<1.5 ) ||
  //                         ( std::fabs(track.x(zT1))<=400.&& std::fabs(X0)<600 &&chi2_track<0.05)
  //                         )
  //                        );
  // }
    
    
  //Case 2 == case 1
  track.setX0(X0);
  track.setRefitX(Refit);
  track.setMaxChi2(maxChi2);
  //===============================
  //============6 HITS===============
  if(track.hits().size()==6)
  {
    if(Refit==0){
      if(iCase == 0 && selected6_0_Case0) return true; //Case 0
      if(iCase == 1 && selected6_0_Case1) return true; //Case 1
      if(iCase == 2 && selected6_0_Case1) return true;//same as case 1 = Case 2
      return false;
    }
  }
  //================================
  //===========5 HITS=================
  if(track.hits().size() == 5){
    if(Refit==0){
      if(iCase == 0 && selected5_0_Case0) return true; //Case0
      if(iCase == 1 && selected5_0_Case1) return true; //Case1
      if(iCase == 2 && selected5_0_Case1) return true; //same as case 1 //Case2==Case1
      return false;
    }
    if(Refit==1){
      if(iCase == 0 && selected5_1_Case0) return true; //Case0
      if(iCase == 1 && selected5_1_Case1) return true; //Case1
      if(iCase == 2 && selected5_1_Case1) return true; //same as case 1 == Case2
    }
  }
  //=================================
  //==============4 HITS===============
  if(track.hits().size()==4)
  {
    if(Refit==0){
      if(iCase ==0) return false; //Case0
      if(iCase ==1 && selected4_0_Case1) return true;//Case1
      if(iCase ==2 && selected4_0_Case1) return true;//Case1 = Case2
      return false;
    }
    if(Refit==1){
      if(iCase==0 && selected4_1_Case0) return true; //Case0
      if(iCase==1 && selected4_1_Case1) return true; //Case1
      if(iCase==2 && selected4_1_Case1) return true; //Case2 = Case1 
      return false;
    }
    if(Refit==2){
      if(iCase==0 && selected4_2_Case0) return true; //Case 
      if(iCase==1 && selected4_2_Case1) return true;
      if(iCase==2 && selected4_2_Case1) return true;
      return false;
    }
  }
  return false;
}



bool PrHybridSeeding::removeWorstAndRefit(PrSeedTrack2& track, int step, unsigned int iCase)
{
  float maxChi2 = 0.;
  PrPlaneCounter2 plCount;
  plCount.set(track.hits().begin(),track.hits().end());
  PrHits::iterator worst = track.hits().begin();
  bool removeUV = false;
  bool removeDuplicateUV = false;
  bool removeUVorX = false;
  bool removeX = false;
  //Whe you have duplicates in a layer ==> remove the hits on that layer
  if( plCount.nbDifferentUV() - plCount.nbSingleUV() >0) {  removeDuplicateUV = true;  removeUV = true;}
  //When only 1 Hit per UV layer
  if(plCount.nbDifferentUV() ==  plCount.nbSingleUV()){
    if(plCount.nbDifferentUV() > plCount.nbDifferentX()){
      //Remove a UV hit if UVHits > NHitsX
      removeUV = true;
    }
    if(plCount.nbDifferentUV() < plCount.nbDifferentX()){
      //Remove a X hit if UVHits < NHitsX
      removeX = true;
    }
    if(plCount.nbDifferentUV() == plCount.nbDifferentX()){
      //Equal foot between the two
      removeUVorX = true;
    }
    if( plCount.nbDifferentUV() == 4) removeX = true; //4 and 4 should never happen!
    if( plCount.nbDifferentX()  == 4) removeUV = true;
  }
  for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ){
    if(removeUVorX){
      if(track.chi2(*itH) >maxChi2){
        maxChi2 = track.chi2( *itH );
        worst = itH;
      }
    }
    if(removeX && !(*itH)->isX()) continue;
    if(removeX)
    { 
      if(track.chi2( *itH ) >maxChi2){
        maxChi2 = track.chi2( *itH);
        worst = itH;
      }
    }
    if(removeUV && (*itH)->isX()) continue;
    if(removeUV && removeDuplicateUV && plCount.nbInPlane( (*itH)->planeCode() ) >1  ){
      if(track.chi2( *itH ) >maxChi2){
        maxChi2 = track.chi2( *itH );
        worst = itH;
      }
    }
    if(removeUV && !removeDuplicateUV){
      if(track.chi2( *itH ) >maxChi2){
        maxChi2 = track.chi2( *itH );
        worst = itH;
      }
    }
  }
  track.hits().erase( worst );
  //plCount.remove(worst);
  
  if(iCase == 10 && m_useImprovedStereo){
    if(track.hits().size()< m_maxNHits )
    {
      //if(track.MaxChi2() > 8 )  return false;
      return fitSimultaneouslyXY(track, step, 10);
    }
  }
  return fitSimultaneouslyXY( track ,step, iCase);
}


//=========================================================================
//  Remove the worst hit and refit.
//=========================================================================
bool PrHybridSeeding::removeWorstAndRefitX ( PrSeedTrack2& track,int step , unsigned int iCase , bool& doRefit) 
{
  if(track.hits().size()>=m_minXPlanes)
  {
    if (msgLevel(MSG::DEBUG)) debug()<<"Removing Worst and Refitting"<<endmsg;
    //Find maxChi2 contribution of an Hit
    double maxChi2 = 0.;
    PrHits::iterator worst = track.hits().begin(); 
    for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ) 
    {
      double chi2 = track.chi2( *itH );
      if ( chi2 > maxChi2 ) {
        maxChi2 = chi2;
        worst = itH;
      }
    }
    if(iCase==10){
      track.hits().erase(worst);
      bool OK = fitXProjection(track, step, 10, doRefit);
      return OK;
    }
    if(iCase!=10){
      track.hits().erase( worst );
      bool doRefit = true;
      bool Ok =  fitXProjection(track , step, iCase ,doRefit);
      return Ok;
    }
    return false;
  }
  return false;
}

void PrHybridSeeding::setChi2 ( PrSeedTrack2& track ) 
{
  float chi2 = 0.;
  int   nDoF = -3;
  // Fitted a parabola
  bool hasStereo = false;
  //for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ) 
  for (PrHit* hit : track.hits()) {
    float d = track.distance( hit );
    if ( hit->dxDy() != 0 ) hasStereo = true;
    //hasStereo = hasStereo || (hit->dxDy() != 0);
    float w = hit->w();
    chi2 += w * d * d;
    nDoF += 1;
  }                                                                          
  if (hasStereo) {
    nDoF -= 2;
  }
  track.setChi2( chi2, nDoF );
}
               


//=========================================================================
//  Set the chi2 of the track
//=========================================================================
void PrHybridSeeding::setChi2X ( PrSeedTrack2& track ) {
  double chi2 = 0.;
  int   nDoF = -3;  // Fitted a parabola
  //bool hasStereo = false;
  //for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ) {
  for (PrHit* hit : track.hits()) {
    if(hit->dxDy() !=0 && msgLevel(MSG::DEBUG)) debug()<<"You were picking up Stereo Layers!!!"<<endmsg;
    double d = track.distance( hit );
    double w = hit->w();
    chi2 += w * d * d;
    nDoF += 1;
  }
  if (msgLevel(MSG::DEBUG)) debug()<<"Chi2 Set for track = \t"<<chi2<<endmsg;
  track.setChi2( chi2, nDoF );
}


//===============================================
//  Print the whole track
//=========================================================================
void PrHybridSeeding::printTrack ( PrSeedTrack2& track ) {
  for ( PrHits::iterator itH = track.hits().begin(); track.hits().end() != itH; ++itH ) {
    info() << format( "dist %7.3f dy %7.2f chi2 %7.2f ", track.distance( *itH ), track.deltaY( *itH ), track.chi2( *itH ) );
    printHit( *itH );
  }
}


//=========================================================================
//  Print the information of the selected hit
//=========================================================================
void PrHybridSeeding::printHit ( const PrHit* hit, std::string title ) {
  info() << "  " << title << " "
         << format( " Plane%3d zone%2d z0 %8.2f x0 %8.2f  size%2d charge%3d coord %8.3f used%2d ",
                    hit->planeCode(), hit->zone(), hit->z(), hit->x(),
                    hit->size(), hit->charge(), hit->coord(), hit->isUsed() );
  if ( m_debugTool ) m_debugTool->printKey( info(), hit->id() );
  if ( matchKey( hit ) ) info() << " ***";
  info() << endmsg;
}


void PrHybridSeeding::findXProjectionsHighMomentum2(unsigned int part)
{
  m_xCandidates.clear();
  for(unsigned int iCase = 0; 3>iCase ; ++iCase){
    PrHits parabolaSeedHits;
    std::vector<PrHits> xHitsLists; //vector of list of Hits
    PrHits xHits;
    //just do the 1st one here //1st layer and last one
    int firstZoneId;
    int lastZoneId;
    if(0 == iCase){
      firstZoneId = s_T1X1 | part;
      lastZoneId  = s_T3X2 | part;
    }else if ( 1 == iCase ){
      firstZoneId = s_T1X2 | part;
      lastZoneId  = s_T3X1 | part;
    }else if ( 2 == iCase ){
      firstZoneId = s_T1X1 | part;
      lastZoneId  = s_T3X1 | part;
    }else if ( 3 == iCase ){
      firstZoneId = s_T1X1 | part;
      lastZoneId  = s_T3X1 | part;
    }
    if (msgLevel(MSG::DEBUG)) debug()<<"\t Loading Case Hit in first and last Zone"<<endmsg;
    PrHitZone* fZone = m_zones[firstZoneId];
    PrHitZone* lZone = m_zones[lastZoneId];
    if (msgLevel(MSG::DEBUG)) debug()<<"Hits in last and first Zone Loaded"<<endmsg;
    //load hits in first zone and last one
    PrHits& fHits = fZone->hits();
    PrHits& lHits = lZone->hits();
    double zFirst     = fZone->z(0.); //First  Zone Z value
    double zLast      = lZone->z(0.); //First  Zone Z value
    double DeltaZ = zLast-zFirst;     //Delta First-Last
    std::vector<PrHitZone*> xZones;
    xZones.reserve(4);
    for (int xZoneId : {s_T1X1, s_T1X2, s_T2X1, s_T2X2, s_T3X1, s_T3X2}){
      xZoneId |= part;
      if (xZoneId != firstZoneId && xZoneId != lastZoneId) {
        xZones.push_back(m_zones[xZoneId]);
      }
    }
    //PrHits::iterator itLBeg = lHits.begin();
    if (msgLevel(MSG::DEBUG)) debug()<<"Hits in the InBetween Zones Loaded"<<endmsg;
    if (msgLevel(MSG::DEBUG)) debug()<<"Will Loop over Hits in first Zone"<<endmsg;
    //for(PrHits::iterator itF = fHits.begin(); fHits.end() != itF; ++itF){

    
    for (PrHit* fHit : fHits) {
      if ( 0 != iCase && fHit->isUsed() && m_removeFlagged ) continue;
      //define search window as a function of the x in the first layer
      double tx_inf =  fHit->x()/zFirst; 
      double xProjeInf = tx_inf*zLast;
      double tolHp = m_TolHighP[iCase] ; 
      //From Branch ImproveIt we change the alphaCOrrection : case 1 : 1988.63; case 2 : 2354.0   
      //For all cases except case = 0
      double maxXl = xProjeInf + tx_inf*m_alphaCorrectionHighP[iCase]  +tolHp;
      double minXl = xProjeInf + tx_inf*m_alphaCorrectionHighP[iCase]  -tolHp;;
      if(maxXl < minXl){
        double temp = maxXl;
        minXl = maxXl;
        maxXl = temp;
      }
      
      if (msgLevel(MSG::DEBUG)) debug()<<"iCase "<<iCase<<"\t X last \t "<<minXl<<"\n\t\t\t Max X last \t "<<maxXl<<endmsg;
      if (msgLevel(MSG::DEBUG)) debug()<<"Will Loop over Last Layer"<<endmsg;
      PrHits::iterator itL = std::lower_bound(lHits.begin(), lHits.end(), minXl, lowerBoundX());
      PrHits::iterator itLEnd = std::upper_bound(lHits.begin(), lHits.end(), maxXl, upperBoundX());
      PrHit* lHit;
      for (; itLEnd != itL; ++itL) {
        lHit = *itL;
        if(nullptr == lHit){ 
          if (msgLevel(MSG::DEBUG)) debug()<<"Not Picking Hits in Last layer in the good search Window"<<endmsg;
          break;
      }
      if(lHit->x() > maxXl) break;
      if ( 0 != iCase && lHit->isUsed() && m_removeFlagged) continue;
      double tx_pickedcombination = (lHit->x()-fHit->x())/DeltaZ;
      parabolaSeedHits.clear();
      parabolaSeedHits.reserve(8);
      double x0 = fHit->x()-tx_pickedcombination*zFirst;
      double CorrX0 = m_hp4_alpha*x0;
      double x0new = x0*(1.+m_hp4_alpha);
      double hp4alpha = m_hp4_alpha;
      for (PrHitZone* xZone : {m_zones[s_T2X1 | part], m_zones[s_T2X2 | part]}) {
        double xProjected = x0 + xZone->z(0.)*tx_pickedcombination;
        double xProjectedCorrected = xProjected+CorrX0;
        double xMax =0.;
        double xMin =0.;
        double max = 0.;
        double min =0.;
        if(x0>0.){
          max = m_hp4_tol; 
          min = x0>400.? -m_hp4_slope*x0 : -m_hp4_tol; // <0 
          xMin = xProjectedCorrected + min;
          xMax = xProjectedCorrected + max;
        }
        if(x0<0.){
          max = x0<-400? -m_hp4_slope*x0: m_hp4_tol; // >0
          min = -m_hp4_tol;
          xMin = xProjectedCorrected + min; 
          xMax = xProjectedCorrected + max;
        }
        if( xMax<xMin && msgLevel(MSG::DEBUG)) debug()<<"\t\t\t\t\t Wrong xMax/xMin"<<endmsg;
        PrHits::iterator itH = std::lower_bound(xZone->hits().begin(), xZone->hits().end(), xMin, lowerBoundX() );
        PrHit* mHit;
        for (; xZone->hits().end() != itH; ++itH ) {
          mHit = *itH;
          if ( mHit->x() > xMax ) break;
          // we can try to avoid this test
          if ( mHit->isUsed() && m_removeFlagged) continue; //Not re use Hits in the middle
          if (msgLevel(MSG::DEBUG)) debug()<<"Filling Parabola Seed Hits"<<endmsg;
          parabolaSeedHits.push_back(mHit);
        }
        if (parabolaSeedHits.size() > 0 && msgLevel(MSG::DEBUG)) debug()<<"ParabolaSeedHits Size \t ="<<parabolaSeedHits.size()<<endmsg;
        //Look for another Hit in last layer
        //end loop to pick up Hits in the 2 inner Layers (was only)
      }
      if (parabolaSeedHits.size()==0) continue;
      //if we don't fine any parabola Seed Hits in the middle 2 Layers then search for another XLast Hit
      // sort the parabola seed hits wrt to distance to the linear projection
      // merged parabolaSeedHits T2-1 & T2-2
      //=======================================================
      // We have 1 Hit in 1st 1 Hit in last and a
      // vector of Hits for in-between
      //=======================================================
      //std::vector<PrHits> xHitsLists; //vector of list of Hits
      xHitsLists.clear();
      
      //=======================================================
      //Sort the ParabolaSeedHits for in-between layers in increasing distance from the Projected Corrected position only when we have more than 1 ParabolaSeedHit
      //=======================================================
      
      if(parabolaSeedHits.size()>=1)
      {
        //Principle of the Lambda funtion, Hits sorted wrt distance from linear Projection 1st-3rd layer
        std::stable_sort( parabolaSeedHits.begin(),parabolaSeedHits.end(),
                          [x0new,tx_pickedcombination, hp4alpha](const PrHit* lhs, const PrHit* rhs)
                          ->bool{
                            double lhsx0 =0 ;
                            double rhsx0 =0 ; 
                            lhsx0 = x0new*(1. + hp4alpha);
                            rhsx0 = x0new*(1. + hp4alpha);
                            return std::fabs(lhs->x() - (lhsx0 + lhs->z()*tx_pickedcombination)) < std::fabs(rhs->x() - (rhsx0 + rhs->z(0)*tx_pickedcombination));} );
      }
      if (msgLevel(MSG::DEBUG)) debug()<<"The Lambda Function Sorting end"<<endmsg;
      unsigned int maxParabolaSeedHits = m_maxParabolaSeedHits;
      if(parabolaSeedHits.size()<m_maxParabolaSeedHits)
      {
        maxParabolaSeedHits = parabolaSeedHits.size();
      }
      for (unsigned int i = 0; i<maxParabolaSeedHits;++i) //build a parabola for each 3 hit combination
      {
        //if (maxParabolaSeedHits==0) break; //maybe a repetition
        double a = 0;
        double b = 0;
        double c = 0; 
        //PrHits xHits;
        xHits.clear();
        if (m_useCubic) {
          solveParabola2(fHit,parabolaSeedHits[i],lHit,a,b,c); //Extrapolation with dRatio
        } else {
          solveParabola(fHit,parabolaSeedHits[i],lHit,a,b,c); //Extrapolation without dRatio
        }
        
        if (msgLevel(MSG::DEBUG)) debug()<<"Parabola Par"
                                         <<"\n a \t"<<a
                                         <<"\n b \t"<<b
                                         <<"\n c \t"<<c<<endmsg;
        if(abs(b) >=0.51) continue;
        if(abs(a) >12e-6) continue;
        //===================================================
        // Look in all the other layers except the
        // 1st/last/zone except the parabolaSeedHit
        //===================================================
        //Loop on all the xZones
        double m_dRatio = m_dRatio0 + c * m_dRatio1 + c * c * m_dRatio2;
        //for ( std::vector<PrHitZone*>::iterator itZ = xZones.begin(); xZones.end() != itZ; ++itZ )
        for (PrHitZone* xZone : xZones) {
          if (msgLevel(MSG::DEBUG)) debug()<<"Selecting ParSeedHits"<<endmsg;

          if (xZone->planeCode() == parabolaSeedHits[i]->planeCode()) continue;
          
          double dz   = xZone->z() - m_geoTool->zReference();
          double xAtZ = a * dz * dz + b * dz + c; //Parabolic computation
          if (m_useCubic) {
            xAtZ= a * dz * dz * (1. + m_dRatio * dz) + b * dz + c; //with Cubic Correction
          }
          double xMaxAtZ = xAtZ + 1.0;   //std::fabs(tx_pickedcombination)+0.5;
          double xMinAtZ = xAtZ - 1.0;     //std::fabs(tx_pickedcombination)-0.5;
          PrHit* bestProj = nullptr;
          double  bestDist = m_maxDeltaPar; //2.0 mm at the moment (Larger)? tighter? (see offline Seeding)
          if (xMinAtZ > xMaxAtZ) {
            if (msgLevel(MSG::DEBUG)) debug()<<"Bad Settings!!!!!!"<<endmsg;
          }
          PrHits::iterator itH = std::lower_bound(xZone->hits().begin() ,xZone->hits().end(),xMinAtZ,lowerBoundX());
          PrHit* hit;
          for (; xZone->hits().end() != itH; ++itH ) {
            hit = *itH;
            if (hit->isUsed() && m_removeFlagged)  continue;
            //if (hit->x() < xMinAtZ ) continue;
            if (hit->x() > xMaxAtZ ) break;
            //Find Hit with Best distance <2.0mm
            if(std::fabs(hit->x() - xAtZ ) < bestDist) 
            {
              bestDist =std::fabs(hit->x() - xAtZ );
              if (msgLevel(MSG::DEBUG)) debug()<<"I found an Hit from projection"<<endmsg;
              bestProj = hit;
            }
          }
          if (bestProj != nullptr)
          {
            xHits.push_back(bestProj);
          }
        }//end loop xZones
        //in xHits are not present the first layer and last + parabola seed hits
        if (msgLevel(MSG::DEBUG)) debug()<<"End Loop in between zones to pick up Projection of parabola"<<endmsg;
        //    xHits.push_back( parabolaSeedHits[i]);
        // Add to the xHits Vector the remaining 3 Hits not considered
        xHits.push_back( parabolaSeedHits[i]);
        xHits.push_back( fHit);
        xHits.push_back( lHit);
        
        if(xHits.size()>6)
        { 
          always()<<"Smething goes wrong!!!! in the creation of the xHits list"<<endmsg;
          always()<<"xHits is bigger than 6 : ERROR"<<endmsg;
        }
        //end parabola Seed Hits loop in other Layers
        //Still in the L0 loop (selection last layer)
        //at this step we have 1 Hit in 1st Layer
        //at this step we have 1 Hit in last Layer
        //at this step we have 1 Hit in Middle Layer
        //at this step we have Hit in remaining X layers at the
        //best distance to extrapolated parabola All of them are
        //inside xHits i want to have at least min_HitXSize
        //UNDER STUDY CASE 0 Only Keep Tracks found with 6 Hits (reduce ghost rate if add UV too
        //1st Case keep only 6 Hits on found track
        //if(iCase == 0 && (xHits.size() <m_minXPlanes)) continue;
        ////2nd Case keep tracks with 4/5/6 hits
        //if(iCase == 1 && xHits.size() <m_minXPlanes) continue;
        if( xHits.size() <  m_minXPlanes)  continue; //Require at least m_minXPlanes
        std::stable_sort(xHits.begin(), xHits.end(), compX());
        bool isEqual = false;
        //Remove xHits in the xHitsLists whicha are basically the same
        for (PrHits& hits : xHitsLists){
          if(msgLevel(MSG::DEBUG)) debug()<<"looping on xHitsLists"<<endmsg;
          if(hits == xHits){
            isEqual = true;
            break;
          }
        }
        if(!isEqual)
        { 
          if (msgLevel(MSG::DEBUG)) debug()<<"Pushing Back xHits List"<<endmsg;
          xHitsLists.push_back( xHits);
        }
      }//End loop parabolaSeedHits
      if (msgLevel(MSG::DEBUG)) debug()<<"End Loop For pick up Parabola Hits and build the xHitsLists"<<endmsg;
      //End loop Parabola Seed Hits
      //-------- Remove Duplicates from search in parabolaSeedHits
      if (msgLevel(MSG::DEBUG)) debug()<<"xHitsLists size before removing duplicates: "<<xHitsLists.size()<<endmsg;
      if (xHitsLists.size() == 0) {
        continue;
      }
      if (xHitsLists.size() > 1) {
        //---Remove Duplicates in the HitsList
        std::stable_sort( xHitsLists.begin(), xHitsLists.end() );
        xHitsLists.erase( std::unique(xHitsLists.begin(), xHitsLists.end()), xHitsLists.end());
      }
      if (msgLevel(MSG::DEBUG)) debug()<<"xHitsLists size after removing duplicates: "<<xHitsLists.size()<<endmsg;
      //Now let's fit the track
      for (PrHits& xHits : xHitsLists){ 
        if (msgLevel(MSG::DEBUG)) debug()<<"Fit Track"<<endmsg;
        //Create the track 
        PrSeedTrack2 temp_track( part , m_geoTool->zReference() , xHits); //Create the track
        //Setters for it: usefull later to parametrise 
        temp_track.setdRatio(0.);
        //I load in the track these info which are then plotted
        if(m_useCubic){
          temp_track.setdRatio(m_dRatio0);
        }
        //-----------------------------------------------------
        //----------------O-_The Fit_-O------------------
        //-----------------------------------------------------
        int nIter = 0;
        bool doRefit = true;
        temp_track.setRefitX(0);
        if (msgLevel(MSG::DEBUG) ){ debug()<<"Attempting to Fit the following Track"<<endmsg; printTrack(temp_track);}
        bool OK = false;
        // if( m_useImproved)
        // {
        //   if(iCase==0 && temp_track.hits().size()>4){
        //   OK = fitXProjection(temp_track,0,iCase,doRefit);
        //   }
        // }
        
        OK = fitXProjection(temp_track, 0, 10, doRefit);
        int i = 0;
        while(!OK){
          if(temp_track.hits().size()==m_minXPlanes){
            OK = false;
            break;
          }
          if(temp_track.MaxChi2() >10.){
            OK = false;
            break;
          }
          i++;
          temp_track.setRefitX(i); 
          if(temp_track.hits().size()>m_minXPlanes)
          { 
            OK = removeWorstAndRefitX(temp_track, 0,10,doRefit);
          }
        }
        setChi2X(temp_track);
        double maxChi2PerDoF = m_maxChi2PerDoF;
        if(m_useImproved) maxChi2PerDoF = 8.0;
        if( OK && 
            temp_track.hits().size() >= m_minXPlanes
            && (( temp_track.chi2PerDoF() < maxChi2PerDoF))){
          
          m_xCandidates.push_back(temp_track); //The X Candidate is created
        }
      }//end Loop xHist:xHitsLists
      }//end loop Last Zone given a firsZone selected
    }//end Loop First Zone
  }//end loop inner case
  std::stable_sort(m_xCandidates.begin(),m_xCandidates.end(),PrSeedTrack2::GreaterBySize());
  //====================================================================
  // Remove clones at this step???, i.e. share more than 2 hits (why not 3?)
  //====================================================================
  // debug()<<"Removing Clones in X Step"<<endmsg;
  if(m_xOnly){
    if(m_removeClonesX) removeClonesX(m_nCommonX);
    for( PrSeedTrack2s::iterator itT1 = m_xCandidates.begin() ; m_xCandidates.end()!=itT1;++itT1)
      if( m_xOnly && (*itT1).valid() ){
        if (msgLevel(MSG::DEBUG)) debug()<<"Fillincg Container Of Tracks"<<endmsg;
        m_trackCandidates.push_back( *itT1 );
      }
  }
}




#ifdef TRUTH_MATCH
bool PrHybridSeeding::matchKey( PrHit* hit, int key){
  LinkedTo<LHCb::MCParticle> fLink( evtSvc() , msgSvc(), LHCb::FTClusterLocation::Defaul);
  LHCb::FTChannelID id0 = hit->id().ftID();
  LHCb::MCParticle* part = fLink.first(id0);
  while(0!=part){
    if(key == part->key() ) return true;
    part.fLink.next();
  }
  return false;
}
bool PrHybridSeeding::match3Hit( const PrHit* hit1, const PrHit* hit2, const PrHit* hit3, int iCase){
  //plot of the 2 hits
  LinkedTo<LHCb::MCParticle> fLink1(evtSvc(),msgSvc(),LHCb::FTClusterLocation::Default);
  LHCb::FTChannelID id1 = hit1->id().ftID();
  bool Associated12 = false;
  bool Associated13 = false;
  bool AllHitAssoc = false;
  LHCb::MCParticle* part = fLink1.first(id1);
  while(0!=part){
    int key = part->key();
    Associated12 = matchKey(hit2, key);
    Associated13 = matchKey(hit3,key);
    if(Associated12 && Associated13) break;
    part=fLink1.next();
  }
  //std::stable_sort(Hits.begin(),Hits.end(),[](const PrHit* lhs, const PrHit* rhs)->bool{return lhs->z()<rhs->z();});??
}
void PrHybridSeeding::matchTrackXStep( const PrSeedTrack2& track){
  
}
void PrHybridSeeding::matchTrackUVStep( const PrSeedTrack2& track){  
}

//ok
bool isWanted(LHCb::MCParticle* mcPart){
  if(mcPart ==nullptr) return false;
  MCTrackInfo trackInfo( evtSvc(),msgSvc());
  if( !hasT(mcPart)) return false;
  if( !(mcPart->originVertex()->isPrimary()) || (mcPart->originVertex()->isDecay())) return false;
  if( m_etaCut && mcPart->eta()>5. || mcPart->eta()<2.) return false;
  if( m_noElectrons && std::fabs(mcPart->particleID().pid() )==11) return false;
  return true;
}

#endif
